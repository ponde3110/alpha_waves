<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<link rel="manifest" href="manifest.json">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#000000">

<title>Î±-waves</title>

<link rel="icon" href="favicon.ico" type="image/x-icon">

<style>

html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: #000;
  overflow: hidden;
}

body {
  padding-bottom: env(safe-area-inset-bottom);
  background: #000;
}


#screen {
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;      /* 100vw â†’ 100% ã«å¤‰æ›´ */
  height: 100%;     /* 100vh â†’ 100% ã«å¤‰æ›´ */
  overflow: hidden;
}

#hud {
  position:fixed;
  top:10px;
  left:0;
  width:100%;
  text-align:center;
  color:#cfe9ff;
  font-family:Arial;
  font-size:16px;
  z-index:10;
  pointer-events:none;
}

#lives {
  position:absolute;
  right:10px;
  bottom:10px;
  color:#cfe9ff;
  font-family:Arial;
  font-size:16px;
  pointer-events:none;
}

#hiscore {
  position:absolute;
  left:10px;
  top:10px;
  color:#cfe9ff;
  font-family:Arial;
  font-size:16px;
}

#score {
  position:absolute;
  right:10px;
  top:10px;
  color:#cfe9ff;
  font-family:Arial;
  font-size:16px;
}

#gameover {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  color: #ff8c1a;
  font-size: 32px;
  font-weight: bold;
  background: linear-gradient(
  to bottom,
  rgba(255,160,60,0.35),
  rgba(120,40,0,0.5)
);

  padding: 16px 32px;              /* â† æ¨ªæ–¹å‘ã‚’åºƒã’ã‚‹ */
  border-radius: 12px;
  z-index: 20;
  display: none;
  font-family: 'Arial Black', Arial, sans-serif;
  box-shadow: 0 4px 10px rgba(0,0,0,0.5);
  border: 1px solid rgba(255, 100, 100, 0.4);

  white-space: nowrap;             /* â† æ”¹è¡Œã•ã›ãªã„ï¼ˆæœ€é‡è¦ï¼‰ */
  /* min-width: 420px; â† æ¨ªé•·ã«ã™ã‚‹ */
}

#startBtn {
  position: fixed;
  top:80%;
  left:50%;
  transform: translate(-50%,-50%);
  padding:12px 24px;
  font-size:24px;
  font-weight: bold;
  border-radius:12px;
  background: linear-gradient(
  to bottom,
  rgba(255,160,60,0.35),
  rgba(120,40,0,0.5)
);
box-shadow:
  0 0 12px rgba(255,140,30,0.6),
  inset 0 0 6px rgba(255,200,120,0.4);

  color:#ff8c1a;
  cursor:pointer;
  z-index:20;
}

#muteBtn {
  position: fixed;
  left: 10px;
  bottom: 10px;   /* â† ç”»é¢æœ€ä¸‹ */
  padding: 0;
  font-size: 24px;
  background: none;
  border: none;
  color: #cfe9ff;
  cursor: pointer;
  z-index: 20;
  outline: none;
}

#title {
  position: fixed;
  top: 25%;
  left: 50%;
  transform: translate(-50%, -50%) scale(1);
  color: #ff8c1a;
  font-family: 'Arial Black', Arial, sans-serif;
  font-size: 48px;
  text-align: center;
  z-index: 12;
  pointer-events: none;
}

#author {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  color: #cfe9ff;
  font-family: Arial, sans-serif;
  font-size: 16px;
  text-align: center;
  z-index: 12;
  pointer-events: none;
}

.title-main{
  font-size:60px;
  letter-spacing:3px;

  color:#ff8c1a;     /* æœ¬ä½“ã®èµ¤ */

  white-space: nowrap;

  text-shadow:
    0 0 6px rgba(255,80,80,0.7),
    0 0 14px rgba(255,60,60,0.6),
    0 0 28px rgba(255,40,40,0.5);

  font-weight:600;
}

.title-sub{
  font-size:26px;
  letter-spacing:2px;
  margin-top:6px;
  color:#cfe9ff;
  font-family:Arial, sans-serif;

  /* æ§ãˆã‚ãªå…‰ */
  text-shadow:
    0 0 4px rgba(200,220,255,0.4),
    0 0 8px rgba(120,180,255,0.3);

  opacity:0.85;
}

#qrCode {
  position: fixed;
  right: 10px;
  bottom: 10px;
  width: 100px;
  height: auto;
  z-index: 30;
  display: none;
  filter: brightness(0.85);
  background: rgba(220,220,220,0.85);   /* â† ã“ã“å¤‰æ›´ */
  padding: 0px;
  border-radius: 8px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.5);
}


.gameover-main {
  /* ä½•ã‚‚æŒ‡å®šã—ãªã„ï¼šä»Šã¾ã§é€šã‚Šèµ¤ãƒ»ã‚µã‚¤ã‚ºç¶­æŒ */
}

.gameover-sub {
  margin-top: 8px;
  font-size: 18px;
  letter-spacing: 0.15em;
  color: #cfe9ff;
  opacity: 0.75;
  font-family: Arial, sans-serif;
}

#controlImg {
  position: fixed;
  left: 10px;
  bottom: 10px;
  width: 100px;
  height: auto;
  z-index: 25;
  pointer-events: none;
  filter: brightness(0.85);
  border-radius: 8px;
  background: rgba(220,220,220,0.85);   /* â† ã“ã“å¤‰æ›´ */
  padding: 0px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.5);
}

#startMessage {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #cfe9ff;
  font-family: Arial, sans-serif;
  font-size: 22px;
  letter-spacing: 0.1em;
  text-align: center;
  opacity: 0;
  pointer-events: none;
  z-index: 15;

  white-space: nowrap;   /* â˜… å¿…é ˆ */
  max-width: 100vw;      /* â˜… ç”»é¢å¹…åˆ¶é™ */
  overflow: hidden;      /* â˜… æŠ˜ã‚Šè¿”ã—é˜²æ­¢ */

  text-shadow:
    0 0 6px rgba(120,180,255,0.6),
    0 0 14px rgba(120,180,255,0.4);

  transition: opacity 0.8s ease;
}

#lifeUpMessage {
  position: fixed;
  top: 40%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 24px;
  color: #ff8c1a;
  font-weight: bold;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s;
  z-index: 50;
  transition: opacity 0.3s, transform 0.3s;
}

.heart {
  color: #cfe9ff;
  font-size: 28px;
  margin-right: 6px;
}

#ruleBtn {
  position: fixed;
  right: 10px;
  bottom: 10px;

  width: 32px;
  height: 32px;
  border-radius: 50%;

  background: rgba(255,255,255,0.2);
  color: #fff;

  font-size: 18px;
  font-weight: bold;

  display: flex;
  align-items: center;
  justify-content: center;

  padding: 0;
  line-height: 1;

  z-index: 20;
}


#ruleOverlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.55);
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

#rulePanel {
  background: rgba(140, 200, 160, 0.60);   /* 0.80ãªã‚‰æ¿ƒ */
  border: 1.5px solid rgba(255,255,255,0.28);
  border-radius: 18px;
  padding: 30px 30px 20px 20px;  /* ä¸Šå³ä¸‹å·¦ */
  max-width: 80vw;
  max-height: 80vh;
  overflow-y: auto;
  color: white;
  position: relative;

  /* ã‚´ã‚·ãƒƒã‚¯ç³»ãƒ•ã‚©ãƒ³ãƒˆçµ±ä¸€ */
  font-family:
    -apple-system,
    BlinkMacSystemFont,
    "Helvetica Neue",
    Arial,
    "Hiragino Kaku Gothic ProN",
    "Yu Gothic",
    Meiryo,
    sans-serif;

  /* â˜… ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸçŠ¶æ…‹ */
  transform: scale(0.85);
  opacity: 0;
  transition: transform 0.3s ease, opacity 0.3s ease;
}

/* è¡¨ç¤ºæ™‚ */
#ruleOverlay.show #rulePanel {
  transform: scale(1);
  opacity: 1;
}


#ruleClose {
  position: fixed;        /* å›ºå®šé…ç½® */
  top: 10px;              /* å³ä¸Šã«é…ç½® */
  right: 10px;

  width: 32px;
  height: 32px;
  border-radius: 50%;

  background: rgba(255,255,255,0.2);
  color: #fff;

  font-size: 18px;
  font-weight: bold;

  display: flex;
  align-items: center;
  justify-content: center;

  padding: 0;
  line-height: 1;

  cursor: pointer;

  z-index: 20;
}




/* âœ¨ ãƒ›ãƒãƒ¼ã§ç™ºå…‰ */
#ruleClose:hover {
  background: rgba(255,255,255,0.18);
  box-shadow: 0 0 12px rgba(255,255,255,0.35);
  transform: scale(1.08);
}

/* ğŸ‘† æŠ¼ã—ãŸã¨ã */
#ruleClose:active {
  transform: scale(0.94);
  box-shadow: 0 0 6px rgba(255,255,255,0.2);
}


.ruleRows {
  display: flex;
  flex-direction: column;
  gap: 10px; /* å„åˆ—ã®é–“éš” */
}

.ruleRow {
  display: flex;
  align-items: center;
  text-align: left;
  width: 100%;
  gap: 0px; /* ã‚¢ã‚¤ã‚³ãƒ³ã¨èª¬æ˜æ–‡ã®é–“éš” */

  padding-left: 3px;   /* â† å›ºå®šå€¤ã«å¤‰æ›´ï¼ˆæƒã†ï¼‰ */
  box-sizing: border-box;
}

.ruleRow canvas,
.ruleIcon {
  width: 80px;          /* â† HTMLã®80pxã¨ä¸€è‡´ã•ã›ã‚‹ */
  height: 80px;
  flex-shrink: 0;
  display: block;
}

.ruleText {
  font-size: 15px;
  display: block;
  
  /* ã‚´ã‚·ãƒƒã‚¯ç³»ãƒ•ã‚©ãƒ³ãƒˆçµ±ä¸€ */
  font-family:
    -apple-system,
    BlinkMacSystemFont,
    "Helvetica Neue",
    Arial,
    "Hiragino Kaku Gothic ProN",
    "Yu Gothic",
    Meiryo,
    sans-serif;
}


#ruleQR,
#ruleControl {
  display: block;
  width: 120px;                  /* â˜… åŒã‚µã‚¤ã‚º */
  height: auto;
  margin: 16px auto 0 auto;      /* â˜… ä¸­å¤®å¯„ã› */
  border-radius: 14px;
}

#ruleControl {
  margin-top: 20px; /* â˜… å°‘ã—é›¢ã™ */
  margin-bottom: 5px;
}

#ruleQR {
  margin-top: 30px; /* â˜… å°‘ã—é›¢ã™ */
  margin-bottom: 5px;
}

.ruleRow:last-child {
  justify-content: center;   /* â˜… ä¸­å¤®å¯„ã› */
}

.ruleRow:last-child .ruleText {
  text-align: center;
}

.ruleCenter {
  justify-content: center;
}

.ruleCenter .ruleText {
  text-align: center;
}

#lives {
  display: flex;
  gap: 8px;
  align-items: center;
}

.heart {
  font-size: 22px;
  color: inherit;
  display: inline-block;
  position: relative;

  /* è¼ªéƒ­ã‚’ä½œã£ã¦å½¢ã‚’å¼·èª¿ */
  text-shadow:
    1px 0 0 rgba(0,0,0,0.45),
   -1px 0 0 rgba(0,0,0,0.45),
    0 1px 0 rgba(0,0,0,0.45),
    0 -1px 0 rgba(0,0,0,0.45),

    0 2px 0 rgba(255,255,255,0.8),   /* ä¸Šå…‰ */
    0 4px 6px rgba(0,0,0,0.55);      /* æµ®éŠå½± */
}


</style>
</head>
<body>

<div id="screen">
  <canvas id="canvas"></canvas>
  <div id="hiscore">HI 0</div>
  <div id="score">SCORE 0</div>
  <div id="lives"></div>
  <div id="gameover">
    <div class="gameover-main">GAME OVER</div>
   <div class="gameover-sub">Î±-wave sync lost</div>
  </div>
  <div id="startMessage">Flow with the Î±-waves</div>
  <div id="title">
    <div class="title-main">Î±-waves</div>
    <div class="title-sub">- sync and relax -</div>
  </div>
  <div id="lifeUpMessage">Life Up!</div>
  <div id="author">&copy; 2026 ponde3110</div>
  <button id="startBtn">START</button>
  <button id="muteBtn">ğŸ”Š</button>
 <button id="ruleBtn">?</button>
</div>

<div id="ruleOverlay">
  <div id="rulePanel">

    <button id="ruleClose">âœ•</button>

    <div id="ruleList" class="ruleRows">

      <div class="ruleRow">
        <canvas id="ruleBall" width="80" height="80"></canvas>
        <span class="ruleText">The Ball â€” Control</span>
      </div>

      <div class="ruleRow">
        <canvas id="ruleTell" width="80" height="80"></canvas>
        <span class="ruleText">Dark Telu â€” Life â†“</span>
      </div>

      <div class="ruleRow">
        <canvas id="ruleHatapie" width="80" height="80"></canvas>
        <span class="ruleText">Art Vata P â€” Life â†‘</span>
      </div>



    </div>

    <img src="control.png" id="ruleControl" alt="controls">
      <div class="ruleRow ruleCenter">
      <span class="ruleText">Start = Neutral & 50k = Life â†‘</span>
      </div>
    <img src="QR.png" id="ruleQR" alt="QR code">
      <div class="ruleRow ruleCenter">
      <span class="ruleText">Scan to Share via QR</span>
      </div>
  </div>
</div>

<script>

/* ===== ç¸¦å›ºå®š ===== */
function lockPortrait() {
  if (screen.orientation && screen.orientation.lock) {
    screen.orientation.lock("portrait").catch(() => {});
  }
}


// ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå¾Œã§ãªã„ã¨åŠ¹ã‹ãªã„ç«¯æœ«ãŒã‚ã‚‹ãŸã‚
document.addEventListener("click", lockPortrait, { once: true });
document.addEventListener("touchstart", lockPortrait, { once: true });


/* ===== Audio ===== */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let audioStarted = false;
const bgGain = audioCtx.createGain();
bgGain.gain.value = 0.04;
bgGain.connect(audioCtx.destination);

const chords = [
  [220,330,440],
  [247,370,494],
  [262,392,523],
  [294,440,587]
];
let chordIndex = 0, chordTimeout;
let muted = localStorage.getItem("muted")==="true";

let sideHitFlash = 0;
let explodeColorPhase = 0;
let nextLifeScore = 50000;

let sideHitFlashLeft = 0;
let sideHitFlashRight = 0;

let hatapieFlash = 0;   // â˜… ã¯ãŸãƒ”ãƒ¼æ¥è§¦æ™‚ã®è‰²å¤‰åŒ–ç”¨

let isLandscape = false;ã€€// å›è»¢æ™‚ã®è­¦å‘Šç”¨
let calibrating = false; // ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«è¨­å®šä¸­ã¯å›è»¢åˆ¤å®šã‚’æ­¢ã‚ã‚‹å¤‰æ•°
let gameOverTimeout = null;ã€€// å›è»¢æ™‚ã®æ™‚è¨ˆã‚’æ­¢ã‚ã‚‹

const muteBtn = document.getElementById("muteBtn");

muteBtn.onclick = () => {
  muted = !muted;
  localStorage.setItem("muted", muted);
  bgGain.gain.value = muted ? 0 : 0.04;   // â†å…ƒã® bgGain ã‚’ä½¿ã†
  muteBtn.textContent = muted ? "ğŸ”‡" : "ğŸ”Š";
};

muteBtn.textContent = muted ? "ğŸ”‡" : "ğŸ”Š";


function playChord() {
  if (isGameOver) return;

  const freqs = [220, 330]; // å„ªã—ã„2éŸ³

  freqs.forEach(f => {
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    osc.type = "triangle";
    osc.frequency.value = f;

    g.gain.value = muted ? 0 : 0.12;

    osc.connect(g);
    g.connect(audioCtx.destination);

    osc.start();

    g.gain.exponentialRampToValueAtTime(
      0.0001,
      audioCtx.currentTime + 2.5
    );

    osc.stop(audioCtx.currentTime + 2.5);
  });

  chordTimeout = setTimeout(playChord, 5000);
}


function hitSound() {
  if (muted) return;

  const now = audioCtx.currentTime;

  /* ===== ãƒã‚¤ã‚ºï¼ˆè¡çªæ„Ÿï¼‰ ===== */
  const bufferSize = audioCtx.sampleRate * 0.12;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);

  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
  }

  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;

  const noiseFilter = audioCtx.createBiquadFilter();
  noiseFilter.type = "highpass";      // â˜… ä½éŸ³ã‚«ãƒƒãƒˆ
  noiseFilter.frequency.value = 600;

  const noiseGain = audioCtx.createGain();
  noiseGain.gain.setValueAtTime(0.35, now);
  noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

  noise.connect(noiseFilter);
  noiseFilter.connect(noiseGain);
  noiseGain.connect(audioCtx.destination);

  /* ===== ãƒ”ãƒƒã¨ã„ã†ä¸­é«˜éŸ³ ===== */
  const osc = audioCtx.createOscillator();
  const oscGain = audioCtx.createGain();

  osc.type = "square";               // â˜… ç›®ç«‹ã¤
  osc.frequency.setValueAtTime(1600, now);
  osc.frequency.exponentialRampToValueAtTime(600, now + 0.08);

  oscGain.gain.setValueAtTime(0.25, now);
  oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

  osc.connect(oscGain);
  oscGain.connect(audioCtx.destination);

  /* ===== å†ç”Ÿ ===== */
  noise.start(now);
  noise.stop(now + 0.2);

  osc.start(now);
  osc.stop(now + 0.12);
}


function bounceSound(){
  if (muted) return;

  const ctx = audioCtx;
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();

  osc.type = "sine";          // æŸ”ã‚‰ã‹ã„éŸ³
  osc.frequency.value = 880; // é«˜ã‚ï¼ˆè»½ã„åå°„æ„Ÿï¼‰

  gain.gain.value = 0.15;
  gain.gain.exponentialRampToValueAtTime(
    0.001,
    ctx.currentTime + 0.12
  );

  osc.connect(gain);
  gain.connect(ctx.destination);

  osc.start();
  osc.stop(ctx.currentTime + 0.12);
}



function destroySound() {
  const now = audioCtx.currentTime;

  // ãƒã‚¤ã‚ºç”Ÿæˆ
  const bufferSize = audioCtx.sampleRate * 2.5;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);

  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
  }

  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;

  // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼ˆå¾ã€…ã«ä½ãæ²ˆã‚€ï¼‰
  const filter = audioCtx.createBiquadFilter();
  filter.type = "lowpass";
  filter.frequency.setValueAtTime(1200, now);
  filter.frequency.exponentialRampToValueAtTime(120, now + 2.5);

  // éŸ³é‡åˆ¶å¾¡
  const gain = audioCtx.createGain();
  gain.gain.setValueAtTime(muted ? 0 : 0.35, now);
  gain.gain.exponentialRampToValueAtTime(0.0001, now + 2.8);

  noise.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);

  noise.start(now);
  noise.stop(now + 3);
}


/* ===== Canvas ===== */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  canvas.width = w;
  canvas.height = h;
}

resize();
addEventListener("resize", resize);

const W = () => canvas.width;
const H = () => canvas.height;
const scoreLabel = document.getElementById("score");
const hiLabel = document.getElementById("hiscore");
const gameoverLabel = document.getElementById("gameover");
const livesLabel = document.getElementById("lives");

const startMessage = document.getElementById("startMessage");  // ã‚¹ã‚¿ãƒ¼ãƒˆæ™‚ã«è¡¨ç¤º â†’ è‡ªå‹•ã§æ¶ˆã™



let offset = 0, score = 0, hiScore = Number(localStorage.getItem("hiScore")||0);
let lives = 3, invincible = 0, isGameOver = false, gameStarted = false, scoreStarted = false;
const roadWidth = 150;
let ballDestroyed = false, ballScale = 1;
let ballX=0, ballY=H()*0.6, ballVX=0, ballVY=0, inputX=0, inputY=0;
const BALL_R = 14;
const keys = {};

// ===== ã‚¹ãƒãƒ›å‚¾ãæ“ä½œ =====
const isIPad =
  /iPad/.test(navigator.userAgent) ||
  (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

let tiltInputX = 0, tiltInputY = 0;

let baseGamma = null;
let baseBeta = null;


function handleOrientation(e) {

  if (e.beta == null || e.gamma == null) return;

  /* =========================================
     â‘  ã‚²ãƒ¼ãƒ é–‹å§‹å‰ â†’ ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«ç”¨ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
     ========================================= */
  if (!gameStarted) {

    neutralSamples.push({
      beta: e.beta,
      gamma: e.gamma
    });

    // æœ€å¤§æ•°ã‚’è¶…ãˆãŸã‚‰å¤ã„ã‚‚ã®ã‚’å‰Šé™¤
    if (neutralSamples.length > NEUTAL_SAMPLE_MAX) {
      neutralSamples.shift();
    }

    return;   // ã‚²ãƒ¼ãƒ é–‹å§‹å‰ã¯ã“ã“ã§çµ‚äº†
  }

  /* =========================================
     â‘¡ ã‚²ãƒ¼ãƒ ä¸­ â†’ åŸºæº–ã¨ã®å·®åˆ†ã§æ“ä½œ
     ========================================= */

  if (baseGamma === null || baseBeta === null) return;

  let x = e.gamma - baseGamma;
  let y = e.beta  - baseBeta;

  /* ===== ç”»é¢å›è»¢è£œæ­£ ===== */
  const angle = (screen.orientation && screen.orientation.angle) || 0;

  switch (angle) {
    case 90:
      [x, y] = [y, -x];
      break;
    case 180:
      x = -x;
      y = -y;
      break;
    case 270:
      [x, y] = [-y, x];
      break;
  }

  /* ===== iPadè£œæ­£ï¼ˆæœ€çµ‚æ®µéšã§é©ç”¨ï¼‰ ===== */
  const isIPad =
    /iPad/.test(navigator.userAgent) ||
    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

  if (isIPad) {
    [x, y] = [-y, x];
  }

  /* ===== æ„Ÿåº¦ ===== */
  const sensitivity = 0.04;

  tiltInputX = x * sensitivity;
  tiltInputY = y * sensitivity;
}

/* ===== ã‚¤ãƒ™ãƒ³ãƒˆç™»éŒ² ===== */
window.addEventListener("deviceorientation", handleOrientation);



/* ===== æ˜Ÿ ===== */
const stars = [];
for (let i=0; i<120; i++) {
  stars.push({
    x: Math.random()*W(),
    y: Math.random()*H(),
    d: Math.random()*2+0.5,
    s: Math.random()*0.8+0.3,
    a: Math.random()*0.6+0.3,
    c: [[255,255,255],[200,220,255],[255,235,200]][Math.random()*3|0]
  });
}

function drawStars() {

  // ===== ç´«ãŒã¯ã£ãã‚Šè¦‹ãˆã‚‹å®‡å®™èƒŒæ™¯ =====
const bg = ctx.createLinearGradient(0, 0, 0, H());

// ä¸Šï¼šã‹ãªã‚Šç´«
bg.addColorStop(0, "#3a0060");

// å°‘ã—ä¸‹
bg.addColorStop(0.25, "#2b0040");

// ä¸­é–“
bg.addColorStop(0.6, "#140020");

// ä¸‹ï¼šã»ã¼é»’
bg.addColorStop(1, "#020008");


  ctx.fillStyle = bg;
  ctx.fillRect(0,0,W(),H());

  stars.forEach(s => {
    s.y += 0.12 * s.d;
    if (s.y > H()) {
      s.y = 0;
      s.x = Math.random()*W();
    }
    ctx.fillStyle = `rgba(${s.c[0]},${s.c[1]},${s.c[2]},${s.a})`;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.s*s.d, 0, Math.PI*2);
    ctx.fill();
  });
}


/* ===== ãƒ†ãƒ«ï¼†ã¯ãŸãƒ”ãƒ¼ ===== */
const holes = [];
const hatapies = [];   // â† ä¸‹ã‹ã‚‰ä¸ŠãŒã‚‹ã€Œã¯ãŸãƒ”ãƒ¼ã€

function spawnHole() {
  holes.push({
    y: -40,
    xOffset: (Math.random() - 0.5) * roadWidth * 0.6,
    r: 6 + Math.random() * (4 + score / 20000),
    h: 12 + Math.random() * 10   // é«˜ã•ï¼ˆç«‹ä½“æ„Ÿç”¨ï¼‰
  });
}

function spawnHatapie() {
  hatapies.push({
    y: H() + 40,   // ç”»é¢ä¸‹ã‹ã‚‰å‡ºç¾
    xOffset: (Math.random() - 0.5) * roadWidth * 0.6,
    r: 6 + Math.random() * 6,
    h: 12 + Math.random() * 10
  });
}




/* ===== é“ ===== */
function roadCenter(y) {
  return W()/2
    + Math.sin((y + offset) * 0.01) * 80
    + Math.sin((y + offset) * 0.03) * 30;
}

function drawRoad() {
  const leftEdge = [];
  const rightEdge = [];

  /* ===== é“ã®ä¸­å¿ƒã¨å¹… ===== */
  for (let y = 0; y <= H(); y += 2) {
    const cx = roadCenter(y);
    const t = y / H();
    const perspective = 0.1 + t * 1.0;
    const w = roadWidth * perspective;

    leftEdge.push({ x: cx - w / 2, y });
    rightEdge.push({ x: cx + w / 2, y });
  }

  /* ===== è·¯é¢ ===== */
  for (let i = 0; i < leftEdge.length; i++) {
    const y = leftEdge[i].y;
    const lx = leftEdge[i].x;
    const rx = rightEdge[i].x;

    const roadGrad = ctx.createLinearGradient(lx, 0, rx, 0);
    roadGrad.addColorStop(0, "#2a7a6d");
    roadGrad.addColorStop(0.35, "#145046");
    roadGrad.addColorStop(0.5, "#0a2a26");
    roadGrad.addColorStop(0.65, "#145046");
    roadGrad.addColorStop(1, "#2a7a6d");

    ctx.fillStyle = roadGrad;
    ctx.fillRect(lx, y, rx - lx, 2);

    // é è¿‘ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆç¸¦æ–¹å‘ï¼‰
    const depthGrad = ctx.createLinearGradient(0, 0, 0, H());
    depthGrad.addColorStop(0, "rgba(0,0,0,0.65)");
    depthGrad.addColorStop(0.45, "rgba(0,0,0,0.25)");
    depthGrad.addColorStop(1, "rgba(255,255,255,0.12)");
    ctx.fillStyle = depthGrad;
    ctx.fillRect(lx, y, rx - lx, 2);
  }

  /* ===== é“ã®ç¸ï¼ˆãƒ’ãƒƒãƒˆæ™‚ã¯è‰²ã ã‘å¤‰ãˆã‚‹ï¼‰ ===== */
  for (let i = 0; i < leftEdge.length; i++) {
    const t = leftEdge[i].y / H();
    const perspective = 0.1 + t * 1.0;
    const alpha = 0.3 + 0.7 * perspective;

    /* --- å·¦ç¸ --- */
    ctx.lineWidth = 3;
    ctx.strokeStyle = sideHitFlashLeft > 0
      ? "rgba(154,135,44,0.45)"        // ãƒ’ãƒƒãƒˆæ™‚ï¼ˆé‡‘è‰²ï¼‰
      : `rgba(40,120,100,${alpha})`;  // é€šå¸¸

    ctx.beginPath();
    ctx.moveTo(leftEdge[i].x, leftEdge[i].y);
    if (i < leftEdge.length - 1) {
      ctx.lineTo(leftEdge[i + 1].x, leftEdge[i + 1].y);
    }
    ctx.stroke();

    /* --- å³ç¸ --- */
    ctx.lineWidth = 3;
    ctx.strokeStyle = sideHitFlashRight > 0
      ? "rgba(154,135,44,0.45)"        // ãƒ’ãƒƒãƒˆæ™‚ï¼ˆé‡‘è‰²ï¼‰
      : `rgba(40,120,100,${alpha})`;  // é€šå¸¸

    ctx.beginPath();
    ctx.moveTo(rightEdge[i].x, rightEdge[i].y);
    if (i < rightEdge.length - 1) {
      ctx.lineTo(rightEdge[i + 1].x, rightEdge[i + 1].y);
    }
    ctx.stroke();
  }

  /* ===== ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¸›ç®— ===== */
  if (sideHitFlashLeft > 0) sideHitFlashLeft--;
  if (sideHitFlashRight > 0) sideHitFlashRight--;

  /* ===== ã‚»ãƒ³ã‚¿ãƒ¼ãƒ©ã‚¤ãƒ³ ===== */
  ctx.strokeStyle = "rgba(140,220,180,0.35)";
  ctx.lineWidth = 2;
  ctx.setLineDash([3, 3]);
  ctx.beginPath();
  for (let i = 0; i < leftEdge.length; i++) {
    const cx = (leftEdge[i].x + rightEdge[i].x) / 2;
    if (i === 0) ctx.moveTo(cx, leftEdge[i].y);
    else ctx.lineTo(cx, leftEdge[i].y);
  }
  ctx.stroke();
  ctx.setLineDash([]);

  /* ===== é“å°‚ç”¨ãƒ•ã‚©ã‚° ===== */
  ctx.save();
  ctx.beginPath();
  for (let i = 0; i < leftEdge.length; i++) {
    if (i === 0) ctx.moveTo(leftEdge[i].x, leftEdge[i].y);
    else ctx.lineTo(leftEdge[i].x, leftEdge[i].y);
  }
  for (let i = rightEdge.length - 1; i >= 0; i--) {
    ctx.lineTo(rightEdge[i].x, rightEdge[i].y);
  }
  ctx.closePath();
  ctx.clip();

  const fog = ctx.createLinearGradient(0, 0, 0, H() * 0.1);
  fog.addColorStop(0, "rgba(20,0,40,1)");
  fog.addColorStop(1, "rgba(20,0,40,0)");
  ctx.fillStyle = fog;
  ctx.fillRect(0, 0, W(), H() * 0.1);
  ctx.restore();

  /* ===== ãƒ†ãƒ«ï¼ˆä¸Šã‹ã‚‰è½ã¡ã‚‹ç‰©ä½“ï¼‰ ===== */
  holes.forEach(o => {
    if (o.y < 0 || o.y > H()) return;

    const t = o.y / H();
    const perspective = 0.1 + t * 1.0;

    const cx = roadCenter(o.y) + o.xOffset;
    const cy = o.y + 6 * perspective;

    const r = o.r * perspective;
    const h = o.h * perspective;

    ctx.fillStyle = `rgba(0,0,0,${0.35 * perspective})`;
    ctx.beginPath();
    ctx.ellipse(cx, cy + h, r * 1.1, r * 0.55, 0, 0, Math.PI * 2);
    ctx.fill();

    const topGrad = ctx.createRadialGradient(cx, cy, 2, cx, cy, r);
    topGrad.addColorStop(0, "#442060");
    topGrad.addColorStop(1, "#140018");
    ctx.fillStyle = topGrad;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fill();

    const sideGrad = ctx.createLinearGradient(cx, cy, cx, cy + h);
    sideGrad.addColorStop(0, "rgba(80,0,120,0.8)");
    sideGrad.addColorStop(1, "rgba(0,0,0,0.95)");
    ctx.fillStyle = sideGrad;
    ctx.beginPath();
    ctx.ellipse(cx, cy + h, r, r * 0.55, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = `rgba(190,130,255,${0.3 + 0.4 * perspective})`;
    ctx.lineWidth = 2 * perspective;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.stroke();
  });

  /* ===== ã¯ãŸãƒ”ãƒ¼ ===== */
  hatapies.forEach((o, index) => {
    if (o.y < 0 || o.y > H()) return;

    const t = o.y / H();
    const p = 0.1 + t * 1.0;

    const cx = roadCenter(o.y) + o.xOffset;
    const floatY = o.y + Math.sin(Date.now()/500 + index) * 6;

    const alpha = 0.5 + 0.5 * Math.sin(Date.now()/400 + index);
    const r = o.r * p;

    const glow = ctx.createRadialGradient(cx, floatY, 1, cx, floatY, r);
    glow.addColorStop(0, `rgba(255,240,245,${alpha})`);
    glow.addColorStop(0.3, `rgba(255,182,193,${alpha})`);
    glow.addColorStop(0.6, `rgba(255,105,180,${alpha})`);
    glow.addColorStop(0.85, `rgba(219,112,147,${alpha * 0.8})`);
    glow.addColorStop(1, `rgba(199,21,133,0)`);

    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(cx, floatY, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = `rgba(255,105,180,${0.5 * p * alpha})`;
    ctx.lineWidth = 1.5 * p;
    ctx.beginPath();
    ctx.arc(cx, floatY, r, 0, Math.PI * 2);
    ctx.stroke();
  });
}




/* ===== ãƒœãƒ¼ãƒ«æç”» ===== */
function drawBall() {
  if (isGameOver) return;

  /* ===== çƒã®ä¸­å¿ƒåº§æ¨™ ===== */
  const cy = gameStarted ? ballY : H() * 0.6;               // Yåº§æ¨™
  const cx = roadCenter(cy) + (gameStarted ? ballX : 0);    // é“ã®ä¸­å¤®ã«é…ç½®
  const t = cy / H();                                       // é è¿‘ä¿‚æ•°
  const perspective = 0.1 + t * 1.0;                        // 0.1ã€œ1.1
  const r = BALL_R * perspective * ballScale;               // ãƒœãƒ¼ãƒ«åŠå¾„ï¼ˆé è¿‘ãƒ»ã‚¹ã‚±ãƒ¼ãƒ«åæ˜ ï¼‰

  /* ===== ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã§ã¯åŠé€æ˜ã«ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹ ===== */
  const alpha = gameStarted ? 1 : 1.0;   // â˜… ã“ã“ã§å¼·åˆ¶çš„ã«ä¸é€æ˜ã«

  /* ===== å½± ===== */
  const shadowWidth = 14 * perspective;  // æ¨ªã‚’å°‘ã—å¤§ãã
  const shadowHeight = 5 * perspective; // ç¸¦ã‚‚å¤§ãã
  const shadowAlpha = 0.4 * perspective; // å¥¥è¡Œãã§è–„ã

  ctx.fillStyle = `rgba(0,0,0,${shadowAlpha})`;
  ctx.beginPath();
  ctx.ellipse(cx, cy + 10 * perspective, shadowWidth, shadowHeight, 0, 0, Math.PI * 2);
  ctx.fill();

  /* ===== é€šå¸¸ãƒ—ãƒ¬ã‚¤ä¸­ ===== */
  if (!ballDestroyed) {
    let g;

if (sideHitFlash > 0) {
  // æ¨ªãƒ’ãƒƒãƒˆæ™‚ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ï¼ˆèµ¤â†’é‡‘è‰²åŠé€æ˜ã«å¤‰æ›´ï¼‰
  const alpha = 0.4; // åŠé€æ˜
  g = ctx.createRadialGradient(
    cx - 6 * perspective,
    cy - 6 * perspective,
    2 * perspective,
    cx,
    cy,
    r * 1.1
  );
  g.addColorStop(0.0, `rgba(230,217,138,${alpha})`);  // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  g.addColorStop(0.25, `rgba(154,135,44,${alpha})`);  // ãƒ€ãƒ¼ã‚¯ã‚´ãƒ¼ãƒ«ãƒ‰
  g.addColorStop(0.55, `rgba(111,98,32,${alpha})`);   // ã‹ãªã‚Šæš—ã„å½±
  g.addColorStop(0.8, `rgba(168,147,50,${alpha})`);   // æˆ»ã‚Šå…‰
  g.addColorStop(1.0, `rgba(255,140,26,${alpha})`);   // å¤–å‘¨ã‚ªãƒ¬ãƒ³ã‚¸

  sideHitFlash--;
    } else {
      // é€šå¸¸ãƒœãƒ¼ãƒ«
      g = ctx.createRadialGradient(
        cx - 5 * perspective,
        cy - 5 * perspective,
        2 * perspective,
        cx,
        cy,
        r * 1.1
      );

// â˜… ã¯ãŸãƒ”ãƒ¼æ™‚ã ã‘å°‘ã—æ¿ƒã
const boost = hatapieFlash > 0 ? 1.15 : 1.0;  // â˜… æ˜åº¦ã‚¢ãƒƒãƒ—
const vivid = hatapieFlash > 0 ? 1.2  : 1.0;  // â˜… å½©åº¦ã‚¢ãƒƒãƒ—
const cool  = hatapieFlash > 0 ? 0.75 : 1.0;  // â˜… é’ã‚’å¼·ãæŠ‘ãˆã‚‹

g.addColorStop(0.0, `rgb(${230*boost*vivid},${217*boost*vivid},${138*boost*cool})`);
g.addColorStop(0.25,`rgb(${154*boost*vivid},${135*boost*vivid},${44*boost*cool})`);
g.addColorStop(0.55,`rgb(${111*boost*vivid},${98*boost*vivid}, ${32*boost*cool})`);
g.addColorStop(0.8, `rgb(${168*boost*vivid},${147*boost*vivid},${50*boost*cool})`);
g.addColorStop(1.0, `rgb(${255*boost*vivid},${140*boost*vivid},${26*boost*cool})`);



    }

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fill();

  } else {
/* ===== çˆ†ç™ºæ¼”å‡ºï¼ˆè†¨å¼µ â†’ éœ§åŒ–ï¼‰ ===== */
explodeFrame += 0.05;  // æ™‚é–“ã®é€²è¡Œ

// ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã‚„ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å¾Œã«é€æ˜åŒ–ã‚’å¤–ã™
const alpha = 1.0;

// ãƒ•ã‚§ãƒ¼ã‚º1: é‡‘å±ãƒœãƒ¼ãƒ«è†¨å¼µ
if (explodeFrame < 20) {
  const expandedR = BALL_R * (1 + explodeFrame * 0.1); // ã‚†ã£ãã‚Šè†¨å¼µ
  const coreAlpha = Math.max(0, 1 - explodeFrame * 0.03); // å¾ã€…ã«é€æ˜åŒ–

  // é‡‘å±ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
  const g = ctx.createRadialGradient(
    cx - 5 * 0.1, // é è¿‘ã«å¿œã˜ã¦å¾®èª¿æ•´
    cy - 5 * 0.1,
    2 * 0.1,
    cx,
    cy,
    expandedR * 1.1
  );
  g.addColorStop(0.0, `rgba(230,217,138,${coreAlpha})`);   // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  g.addColorStop(0.25, `rgba(154,135,44,${coreAlpha})`);   // ãƒ€ãƒ¼ã‚¯ã‚´ãƒ¼ãƒ«ãƒ‰
  g.addColorStop(0.55, `rgba(111,98,32,${coreAlpha})`);    // ã‹ãªã‚Šæš—ã„å½±
  g.addColorStop(0.8, `rgba(168,147,50,${coreAlpha})`);    // æˆ»ã‚Šå…‰
  g.addColorStop(1.0, `rgba(255,140,26,${coreAlpha})`);    // å¤–å‘¨ã‚ªãƒ¬ãƒ³ã‚¸

  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(cx, cy, expandedR, 0, Math.PI * 2);
  ctx.fill();
}

// ãƒ•ã‚§ãƒ¼ã‚º2: éœ§çŠ¶ç²’å­
else {
  const fogFrame = explodeFrame - 20; // éœ§é–‹å§‹ãƒ•ãƒ¬ãƒ¼ãƒ 
  const particleCount = 25; // ç²’å­æ•°
  for (let i = 0; i < particleCount; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 2 + 0.5;
    const px = cx + Math.cos(angle) * fogFrame * speed * 1.5;
    const py = cy + Math.sin(angle) * fogFrame * speed * 1.5;
    const pr = Math.random() * 1 + 0.3;
    const alpha = Math.max(0, 0.5 - fogFrame * 0.03);

    // é‡‘å±æ„Ÿã®ã‚ã‚‹å°ç²’å­
    const shade = 180 + Math.floor(Math.random() * 75);
    ctx.fillStyle = `rgba(${shade},${shade},0,${alpha})`;

    ctx.beginPath();
    ctx.arc(px, py, pr, 0, Math.PI * 2);
    ctx.fill();
  }
}




  }
}


/* ===== ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ ===== */
function updateGameOver() {

  // â˜… æ¨ªå‘ãä¸­ã¯å®Œå…¨åœæ­¢
  if (isLandscape) return;

  if (isGameOver) return;

  lives = 0;
  updateLivesDisplay();

  clearTimeout(chordTimeout);
  isGameOver = true;

  // æ¨ªå‘ããªã‚‰GAME OVERè¡¨ç¤ºã—ãªã„
  if (!isLandscape) {
    gameoverLabel.style.display = "block";
  }

  hiScore = Math.max(hiScore, score);
  localStorage.setItem("hiScore", Math.floor(hiScore));
  hiLabel.textContent = "HI " + Math.floor(hiScore);

gameOverTimeout = setTimeout(() => {

  gameStarted = false;
  isGameOver = false;

  holes.length = 0;
  hatapies.length = 0;

  invincible = 0;
  sideHitFlash = 0;
  sideHitFlashLeft = 0;
  sideHitFlashRight = 0;
  hatapieFlash = 0;

  gameoverLabel.style.display = "none";

  title.style.display = "block";
  author.style.display = "block";
  startBtn.style.display = "block";
  ruleBtn.style.display = "block";

  ballX = 0;
  ballY = H() * 0.6;
  ballVX = 0;
  ballVY = 0;
  inputX = 0;
  inputY = 0;

}, 3000);
}




/* ===== ã‚­ãƒ¼æ“ä½œ ===== */
addEventListener("keydown", e => {
  keys[e.code] = true;
  if(!scoreStarted && (e.code==="ArrowLeft" || e.code==="ArrowRight")) scoreStarted = true;
});
addEventListener("keyup", e => keys[e.code] = false);

/* ===== ãƒ©ã‚¤ãƒ•è¡¨ç¤º ===== */
const maxLives = 5;
function updateLivesDisplay() {
  // ãƒˆãƒƒãƒ—ç”»é¢ã§ã¯è¡¨ç¤ºã—ãªã„
  if (!gameStarted) {
    livesLabel.innerHTML = "";
    return;
  }

  livesLabel.innerHTML = "";

  // ãƒãƒ¼ãƒˆã‚’å˜ç´”ã«è¡¨ç¤ºã™ã‚‹ã ã‘
  for (let i = 0; i < lives; i++) {
    const heart = document.createElement("span");
    heart.className = "heart";  // CSSã¯å˜ç´”ãªã‚¹ã‚¿ã‚¤ãƒ«ã ã‘ä½¿ç”¨
    heart.textContent = "â™¥";
    livesLabel.appendChild(heart);
  }
}



/* ===== ãƒœãƒ¼ãƒ«æ›´æ–° ===== */
function updateBall(){
  if (ballDestroyed) return;

  /* ===== å…¥åŠ›å‡¦ç† ===== */
  const tx = (keys.ArrowRight ? 1 : 0) - (keys.ArrowLeft ? 1 : 0);
  const ty = (keys.ArrowDown  ? 1 : 0) - (keys.ArrowUp   ? 1 : 0);

  const targetX = tx + tiltInputX;
  const targetY = ty + tiltInputY;


  inputX += (targetX - inputX) * 0.02;
  inputY += (targetY - inputY) * 0.02;

  ballVX += inputX * 0.06;
  ballVY += inputY * 0.06;

  ballVX *= 0.96;
  ballVY *= 0.96;

  const t = ballY / H();
  const perspective = 0.1 + t * 1.0;
  const limit = (roadWidth * perspective) / 2 - BALL_R;

  const bouncePower = 5.0;

  /* ===== ç§»å‹• ===== */
  ballX += ballVX;
  ballY += ballVY;

  /* ===== ä¸Šç«¯ ===== */
  const upperLimit = H() * 0.2;
  if (ballY <= upperLimit) {
    ballY = upperLimit;
    ballVY = +bouncePower;

    if (Math.abs(ballVX) < 0.3) {
      ballVX = (Math.random() < 0.5 ? -1 : 1) * 0.7;
    } else {
      ballVX *= 1.15;
    }
    bounceSound();
  }

  /* ===== ä¸‹ç«¯ ===== */
  if (ballY >= H() - 20) {
    ballY = H() - 20;
    ballVY = -bouncePower;

    if (Math.abs(ballVX) < 0.3) {
      ballVX = (Math.random() < 0.5 ? -1 : 1) * 0.7;
    } else {
      ballVX *= 1.15;
    }
    bounceSound();
  }

  /* ===== å·¦å³ ===== */
  if (ballX >= limit && invincible <= 0) {
    ballVX *= -1.1;
    invincible = 120;
    sideHitFlashRight = 120;
    sideHitFlash = 120;

    hitSound();

    lives--;
    updateLivesDisplay();


    if (lives === 0) gameOverPending = true;
  }

  if (ballX <= -limit && invincible <= 0) {
    ballVX *= -1.1;
    invincible = 120;
    sideHitFlashLeft = 120;
    sideHitFlash = 120;

    hitSound();

    lives--;
    updateLivesDisplay();
    if (lives === 0) gameOverPending = true;
  }

  /* ===== ãƒ†ãƒ«ã¨ã®è¡çªåˆ¤å®š ===== */
holes.forEach((o, i) => {

  if (invincible > 0) return;

  const tObj = o.y / H();
  const pObj = 0.1 + tObj * 1.0;

  const cx = roadCenter(o.y) + o.xOffset;

  // â˜… æå†™ã¨åŒã˜æ¥åœ°è£œæ­£ã‚’åæ˜ 
  const cy = o.y + 6 * pObj;

  const objR = o.r * pObj;

  const tBall = ballY / H();
  const pBall = 0.1 + tBall * 1.0;

  const ballCX = roadCenter(ballY) + ballX;
  const ballCY = ballY;
  const ballR  = BALL_R * pBall;

  const dx = ballCX - cx;
  const dy = ballCY - cy;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist < ballR + objR * 0.85) {

      invincible = 120;
      sideHitFlash = 120;   // â˜… ã“ã‚Œã‚’è¿½åŠ ï¼ˆåŠé€æ˜åŒ–ï¼‰
    lives--;
    updateLivesDisplay();
    tellDestroySound();


    holes.splice(i,1);


    if (lives <= 0) gameOverPending = true;
  }
});

/* ===== ã¯ãŸãƒ”ãƒ¼ã¨ã®è¡çªåˆ¤å®š ===== */
hatapies.forEach((o, i) => {
  const tObj = o.y / H();
  const pObj = 0.1 + tObj * 1.0;

  const cx = roadCenter(o.y) + o.xOffset;
  const cy = o.y + 6 * pObj;   // æ¥åœ°è£œæ­£
  const objR = o.r * pObj;

  const tBall = ballY / H();
  const pBall = 0.1 + tBall * 1.0;

  const ballCX = roadCenter(ballY) + ballX;
  const ballCY = ballY;
  const ballR  = BALL_R * pBall;

  const dx = ballCX - cx;
  const dy = ballCY - cy;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist < ballR + objR * 0.85) {
    // ===== æ¥è§¦æ™‚ã®å‡¦ç† =====
    hatapieFlash = 120;   // â˜… 1ç§’ã ã‘è‰²ã‚’æ¿ƒã
    if (lives < maxLives) {
      lives++;                  // ãƒ©ã‚¤ãƒ•å¢—åŠ ï¼ˆä¸Šé™5ï¼‰
      updateLivesDisplay();     // ãƒ©ã‚¤ãƒ•è¡¨ç¤ºæ›´æ–°
      hatapiesSound();          // åé›†éŸ³

      // è¡¨ç¤ºãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®åˆ‡ã‚Šæ›¿ãˆ
      if (lives === maxLives) {
        showLifeUpMessage("Max Life!"); // â˜… ãƒ©ã‚¤ãƒ•ä¸Šé™æ™‚
        lifeUpMessage.style.color = "#ffd700"; // ã‚´ãƒ¼ãƒ«ãƒ‰
      } else {
        showLifeUpMessage("Life Up!");
        lifeUpMessage.style.color = "#ff8c1a"; // ãƒãƒ¼ãƒˆè‰²
      }
    }

  // æ¥è§¦æ¸ˆã¿ã¯ãŸãƒ”ãƒ¼ã‚’å‰Šé™¤
  hatapies.splice(i, 1);
}
});

/* ===== ã¯ãŸãƒ”ãƒ¼è‰²å¤‰åŒ–ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ ===== */
if (hatapieFlash > 0) hatapieFlash--;

/* ===== ã‚¯ãƒ©ãƒ³ãƒ— ===== */
if (ballX >  limit) ballX =  limit;
if (ballX < -limit) ballX = -limit;
if (ballY < 20)     ballY = 20;
if (ballY > H() - 20) ballY = H() - 20;

/* ===== ç„¡æ•µæ™‚é–“ã‚«ã‚¦ãƒ³ãƒˆ ===== */
if (invincible > 0) invincible--;

}




let gameOverPending = false;
let explodeFrame = 0;

/* ===== ãƒ«ãƒ¼ãƒ— ===== */
function loop(){

  // ===== æ¨ªå‘ããªã‚‰å®Œå…¨åœæ­¢ =====
if (isLandscape) {

  // â‘  ã¾ãšé€šå¸¸æç”»ï¼ˆèƒŒæ™¯ã‚„é“ãªã©ï¼‰
  // â€» ã“ã“ã§ã¯ä½•ã‚‚æ­¢ã‚ãšã€ã™ã§ã«æã‹ã‚Œã¦ã„ã‚‹ç”»é¢ã‚’ä½¿ã†

  // â‘¡ åŠé€æ˜ã®æš—å¹•ã‚’ã‹ã‘ã‚‹
  ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // â‘¢ è­¦å‘Šãƒ†ã‚­ã‚¹ãƒˆ
  ctx.fillStyle = "white";
  ctx.font = "bold 28px sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(
    "Please rotate your device to portrait mode",
    canvas.width / 2,
    canvas.height / 2
  );

  requestAnimationFrame(loop);
  return;
}


  // ===== ã“ã“ã‹ã‚‰ä¸‹ãŒé€šå¸¸ã‚²ãƒ¼ãƒ å‡¦ç† =====


  if(!hiLabel.dataset.init){
    hiLabel.textContent = "HI " + Math.floor(hiScore);
    hiLabel.dataset.init = true;
  }

  drawStars();
  drawRoad();

  // ===== ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é€Ÿåº¦åˆ¶å¾¡ï¼ˆå®Œå…¨ãƒ»åœæ­¢ã—ãªã„ï¼‰=====

  const baseSpeed = 0.12;   // æœ€ä½é€Ÿåº¦ã‚’ä¸‹ã’ã‚‹

if (gameStarted) {

  // ä¸Šã«è¡Œã£ã¦ã‚‚æš´èµ°ã—ãªã„ forward
  let forward = (ballY / H()) * 0.9;


  // æœ€å¤§é€Ÿåº¦ã‚’åˆ¶é™
  forward = Math.min(forward, 0.9);

  offset += baseSpeed + forward;

 // ãƒ†ãƒ«ã¨ã¯ãŸãƒ”ãƒ¼ã‚’ç™ºç”Ÿï¼†æµã™å‡¦ç†
const tellLevel = Math.min(5, 1 + score / 100000); // 20000ãªã‚‰åœ°ç„

if (
  gameStarted &&
  score >= 7500 &&            // â˜… 7500ç‚¹è¶…ãˆã¦ã‹ã‚‰è§£ç¦
  Math.random() < 0.0010 * tellLevel
) {
  spawnHole();
}

// ===== ã¯ãŸãƒ”ãƒ¼å‡ºç¾å‡¦ç† =====
if (gameStarted) {

  // ãƒ©ã‚¤ãƒ•ãŒæº€ã‚¿ãƒ³5ãªã‚‰æ–°ã—ã„ã¯ãŸãƒ”ãƒ¼ã¯ç”Ÿæˆã—ãªã„
  if (lives < 5 && Math.random() < 0.0001) {
    spawnHatapie();
  }

  // ãƒ©ã‚¤ãƒ•ãŒ5ã«ãªã£ãŸã‚‰ã€ç”»é¢ä¸Šã®ã¯ãŸãƒ”ãƒ¼ã‚’ã™ã¹ã¦æ¶ˆã™
  if (lives >= 5 && hatapies.length > 0) {
    hatapies.length = 0;  // é…åˆ—ã‚’ç©ºã«ã™ã‚‹
  }
}



holes.forEach(h => {
  h.y += 0.6;ã€€// 1.4ãªã‚‰å¤šã‚
});

hatapies.forEach(h => {
  h.y -= 0.6;   // â† ä¸Šã¸ä¸Šæ˜‡
});



  if (!isGameOver) {
    score += (0.25 + forward) * 10;
  }
}
 else {
    // æœ¬å½“ã®ãƒˆãƒƒãƒ—ç”»é¢
    offset += baseSpeed;
  }

  if(gameStarted && !isGameOver) updateBall();

  drawBall();
  scoreLabel.textContent = "SCORE " + Math.floor(score);

// ===== ã‚¹ã‚³ã‚¢ã«ã‚ˆã‚‹ãƒ©ã‚¤ãƒ•å›å¾©ï¼ˆä¿®æ­£ç‰ˆãƒ»ç¢ºå®šï¼‰=====
if (score >= nextLifeScore) {

  if (lives < maxLives) {
    lives++;

    lifeUpSound();

    if (lives === maxLives) {
      lifeUpMessage.style.color = "#ffd700"; // gold
      showLifeUpMessage("Max Life!");   // â˜… æº€ã‚¿ãƒ³è¡¨ç¤º
    } else {
      lifeUpMessage.style.color = "#ff8c1a"; // heart color
      showLifeUpMessage("Life Up!");
    }

    updateLivesDisplay();
  }

  nextLifeScore += 50000;
}


  if(gameOverPending && !isGameOver){
    if(Math.abs(ballVX) < 1 && Math.abs(ballVY) < 1){
      ballDestroyed = true;
      destroySound();
      explodeFrame = 0;   // â† è¿½åŠ 
      explodeColorPhase = 0;   // â˜… è¿½åŠ 
      gameOverPending = false;
      setTimeout(()=>{
        updateGameOver();
        ballDestroyed = false;
        ballScale = 1;
      },1000);
    }
  }

  requestAnimationFrame(loop);


}

loop();


/* ===== ã‚¿ã‚¤ãƒˆãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ ===== */
const title = document.getElementById("title");
const author = document.getElementById("author");
let titleScale = 1, scaleDirection = 1;
function animateTitle() {
  if(!gameStarted){
    titleScale += 0.0025 * scaleDirection;
    if(titleScale > 1.15) scaleDirection = -1;
    if(titleScale < 0.95) scaleDirection = 1;
    title.style.transform = `translate(-50%, -50%) scale(${titleScale})`;
  }
  requestAnimationFrame(animateTitle);
}
animateTitle();

/* ===== STARTãƒœã‚¿ãƒ³ï¼ˆiPadå®Œå…¨å¯¾å¿œç‰ˆï¼‰ ===== */
let neutralSamples = [];
const NEUTAL_SAMPLE_MAX = 30;   // 20ã€œ40æ¨å¥¨
let neutralReady = false;

/* ===== STARTãƒœã‚¿ãƒ³ï¼ˆiPadå®Œå…¨å®‰å®šç‰ˆï¼‰ ===== */
startBtn.onclick = async () => {

  /* ===== ã‚¸ãƒ£ã‚¤ãƒ­è¨±å¯å–å¾—ï¼ˆiOSå¯¾ç­–ï¼‰===== */
  try {
    if (
      typeof DeviceOrientationEvent !== "undefined" &&
      typeof DeviceOrientationEvent.requestPermission === "function"
    ) {
      const permission = await DeviceOrientationEvent.requestPermission();
      if (permission !== "granted") return;
    }
  } catch (err) {
    console.error(err);
  }

  /* ===== ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«å†å–å¾—é–‹å§‹ ===== */
  neutralSamples = [];
  neutralReady = false;

  // ç´„0.5ç§’é–“ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
  const CALIBRATION_TIME = 500;

  setTimeout(async () => {

    /* ===== å¹³å‡å€¤ã§ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«ç¢ºå®š ===== */
    if (neutralSamples.length > 5) {

      let sumBeta = 0;
      let sumGamma = 0;

      neutralSamples.forEach(s => {
        sumBeta  += s.beta;
        sumGamma += s.gamma;
      });

      baseBeta  = sumBeta  / neutralSamples.length;
      baseGamma = sumGamma / neutralSamples.length;

    } else {
      // ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ãŒã¾ã å°‘ãªã„å ´åˆ
      baseBeta  = 0;
      baseGamma = 0;
    }

    /* ===== UIéè¡¨ç¤º ===== */
    ruleBtn.style.display = "none";
    startBtn.style.display = "none";
    title.style.display = "none";
    author.style.display = "none";

    /* ===== ã‚²ãƒ¼ãƒ åˆæœŸåŒ– ===== */
    invincible = 0;
    sideHitFlash = 0;
    sideHitFlashLeft = 0;
    sideHitFlashRight = 0;
    hatapieFlash = 0;

    if ('wakeLock' in navigator) enableWakeLock();

    gameStarted = true;
    scoreStarted = true;
    isGameOver = false;

    lives = 3;
    updateLivesDisplay();
    score = 0;
    nextLifeScore = 50000;

    ballX = 0;
    ballY = H() * 0.6;
    ballVX = 0;
    ballVY = 0;

    inputX = 0;
    inputY = 0;

    sideHitFlash = 0;

    if (audioCtx.state === "suspended") await audioCtx.resume();
    playChord();

    /* ===== ã‚¹ã‚¿ãƒ¼ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ===== */
    startMessage.textContent = "Flow with the Î±-waves";
    setTimeout(() => {
      startMessage.style.opacity = "0";
    }, 1500);

  }, CALIBRATION_TIME);
};




// ===== ENTERã‚­ãƒ¼ã§ã‚¹ã‚¿ãƒ¼ãƒˆ =====
addEventListener("keydown", e => {
  if (!gameStarted && (e.code === "Enter" || e.code === "NumpadEnter")) {
    startBtn.onclick(); // ãƒœã‚¿ãƒ³ã®å‡¦ç†ã‚’ãã®ã¾ã¾å‘¼ã³å‡ºã™
  }
});

let wakeLock = null;

// Wake Lockã‚’è¦æ±‚ã™ã‚‹é–¢æ•°
async function enableWakeLock() {
  try {
    wakeLock = await navigator.wakeLock.request('screen');
    // console.logã ã‘ã«ã™ã‚‹ã®ã§ç”»é¢è¡¨ç¤ºã¯ãªã—
    console.log('Wake Lock ãŒæœ‰åŠ¹ã«ãªã‚Šã¾ã—ãŸ');

    wakeLock.addEventListener('release', () => {
      console.log('Wake Lock ãŒè§£é™¤ã•ã‚Œã¾ã—ãŸ');
    });
  } catch (err) {
    console.error('Wake Lock ã®å–å¾—ã«å¤±æ•—:', err);
  }
}

// Wake Lockã‚’è§£é™¤ã™ã‚‹é–¢æ•°
function disableWakeLock() {
  if (wakeLock !== null) {
    wakeLock.release();
    wakeLock = null;
    console.log('Wake Lock ã‚’è§£é™¤ã—ã¾ã—ãŸ');
  }
}

// ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«å‘¼ã¶
enableWakeLock();

// ã‚¿ãƒ–éè¡¨ç¤ºâ†’è¡¨ç¤ºã«ãªã£ãŸã¨ãã«å†å–å¾—
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    enableWakeLock();
  } else {
    wakeLock = null;
  }
});

// ===== ãƒ©ã‚¤ãƒ•å›å¾©ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ =====
const lifeUpMessage = document.getElementById("lifeUpMessage");

function showLifeUpMessage(text = "Life Up!") {
  lifeUpMessage.textContent = text;
  lifeUpMessage.style.opacity = 1;

  setTimeout(() => {
    lifeUpMessage.style.opacity = 0;
  }, 800);
}

function lifeUpSound() {
  if (muted) return;       // â˜… ãƒŸãƒ¥ãƒ¼ãƒˆå¯¾å¿œ
  if (!audioCtx) return;

  const osc1 = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  // éŸ³è‰²
  osc1.type = "sine";
  osc2.type = "triangle";

  // å‘¨æ³¢æ•°ï¼ˆãƒãƒ£ãƒªãƒ³æ„Ÿï¼‰
  osc1.frequency.setValueAtTime(1200, audioCtx.currentTime);
  osc2.frequency.setValueAtTime(1800, audioCtx.currentTime);

  gain.gain.setValueAtTime(0.18, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(
    0.0001,
    audioCtx.currentTime + 0.35
  );

  osc1.connect(gain);
  osc2.connect(gain);
  gain.connect(audioCtx.destination);

  osc1.start();
  osc2.start();

  osc1.stop(audioCtx.currentTime + 0.35);
  osc2.stop(audioCtx.currentTime + 0.35);
}

function ballPerspectiveRadius(y) {
  const t = y / H();
  return BALL_R * t * ballScale;
}



// ===== ãƒ†ãƒ«ã®æ¶ˆæ»…éŸ³ =====
function tellDestroySound() {
  if (muted) return;

  const now = audioCtx.currentTime;

  // å£°ã®æ¯æˆåˆ†
  const bufferSize = audioCtx.sampleRate * 0.09;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);

  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
  }

  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;

  // ãƒ•ã‚©ãƒ«ãƒãƒ³ãƒˆï¼ˆäººã®å£°å¸¯åŸŸï¼‰
  const f1 = audioCtx.createBiquadFilter();
  f1.type = "bandpass";
  f1.frequency.value = 700;   // ãƒ†

  const f2 = audioCtx.createBiquadFilter();
  f2.type = "bandpass";
  f2.frequency.value = 1800; // ãƒ«

  const f3 = audioCtx.createBiquadFilter();
  f3.type = "bandpass";
  f3.frequency.value = 2600;  // å­éŸ³è¼ªéƒ­

  const gain = audioCtx.createGain();
  gain.gain.setValueAtTime(0.25, now);
  gain.gain.linearRampToValueAtTime(0.05, now + 0.04);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.16);

  noise.connect(f1);
  f1.connect(f2);
  f2.connect(f3);
  f3.connect(gain);
  gain.connect(audioCtx.destination);

  noise.start(now);
  noise.stop(now + 0.16);

  // å£°ã®èŠ¯ï¼ˆå–‰ï¼‰
  const osc = audioCtx.createOscillator();
  const og = audioCtx.createGain();

  osc.type = "sawtooth";
  osc.frequency.setValueAtTime(210, now);
  osc.frequency.exponentialRampToValueAtTime(160, now + 0.12);

  og.gain.setValueAtTime(0.07, now);
  og.gain.exponentialRampToValueAtTime(0.001, now + 0.16);

  osc.connect(og);
  og.connect(audioCtx.destination);

  osc.start(now);
  osc.stop(now + 0.16);
}

// â˜… ã¯ãŸãƒ”ãƒ¼å–å¾—éŸ³ï¼ˆãƒ”ã‚³ãƒ”ã‚³ç³»ï¼‰ä½œæˆ
function hatapiesSound() {
  if (muted) return;   // â˜… ãƒŸãƒ¥ãƒ¼ãƒˆå¯¾å¿œ
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const now = ctx.currentTime;

  // ã€Œã¯ã€ã€ŒãŸã€ã€Œã´ãƒ¼ã€ã®é †ã«å‘¨æ³¢æ•°ã‚’å¤‰ãˆã¦å†ç”Ÿ
  const notes = [
    { freq: 660, duration: 0.08 },  // ã¯ï¼ˆçŸ­ã‚ä½éŸ³ï¼‰
    { freq: 880, duration: 0.08 },  // ãŸï¼ˆçŸ­ã‚ä¸­éŸ³ï¼‰
    { freq: 1320, duration: 0.18 }  // ã´ãƒ¼ï¼ˆå°‘ã—é•·ã‚é«˜éŸ³ï¼‰
  ];

  let currentTime = now;

  notes.forEach(n => {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = "sine";           // å¯æ„›ã„éŸ³
    osc.frequency.value = n.freq;

    gain.gain.value = 0.15;

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(currentTime);
    osc.stop(currentTime + n.duration);

    // å¾ã€…ã«éŸ³ã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
    gain.gain.setValueAtTime(0.15, currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, currentTime + n.duration);

    currentTime += n.duration;
  });
}


// ===== ãƒ«ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ =====
const ruleBtn = document.getElementById("ruleBtn");

ruleBtn.onclick = () => {
  alert("ãƒ«ãƒ¼ãƒ«ç”»é¢ã‚’é–‹ãã¾ã™");
};

document.addEventListener("DOMContentLoaded", () => {

  const ruleBtn = document.getElementById("ruleBtn");
  const ruleOverlay = document.getElementById("ruleOverlay");
  const ruleClose = document.getElementById("ruleClose");

  if (!ruleBtn || !ruleOverlay || !ruleClose) {
    console.warn("rule UI not ready");
    return;
  }

ruleBtn.onclick = () => {
  ruleOverlay.style.display = "flex";
  requestAnimationFrame(() => {
    ruleOverlay.classList.add("show");
  });
};

ruleClose.onclick = () => {
  ruleOverlay.classList.remove("show");
  setTimeout(() => {
    ruleOverlay.style.display = "none";
  }, 300);
};



});


/* =========================
   ãƒ«ãƒ¼ãƒ«ç”»é¢ç”¨ Canvas æç”»
   ========================= */

function drawRuleBall() {
  const c = document.getElementById("ruleBall");
  const ctx = c.getContext("2d");

  const cx = 40, cy = 40, r = 22;
  const perspective = 1;

  const g = ctx.createRadialGradient(
    cx - 5 * perspective,
    cy - 5 * perspective,
    2 * perspective,
    cx,
    cy,
    r * 1.1
  );
  g.addColorStop(0.0, "#e6d98a");
  g.addColorStop(0.25, "#9a872c");
  g.addColorStop(0.55, "#6f6220");
  g.addColorStop(0.8, "#a89332");
  g.addColorStop(1.0, "#ff8c1a");

  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fill();
}

function drawRuleTell() {
  const c = document.getElementById("ruleTell");
  const ctx = c.getContext("2d");

  const cx = 40, cy = 38, r = 18, h = 14;

  // å½±
  ctx.fillStyle = "rgba(0,0,0,0.5)";
  ctx.beginPath();
  ctx.ellipse(cx, cy + h + 4, r * 1.1, r * 0.55, 0, 0, Math.PI * 2);
  ctx.fill();

  // ä¸Šé¢
  const topGrad = ctx.createRadialGradient(cx, cy, 2, cx, cy, r);
  topGrad.addColorStop(0, "#442060");
  topGrad.addColorStop(1, "#140018");

  ctx.fillStyle = topGrad;
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fill();

  // å´é¢
  const sideGrad = ctx.createLinearGradient(cx, cy, cx, cy + h);
  sideGrad.addColorStop(0, "rgba(80,0,120,0.8)");
  sideGrad.addColorStop(1, "rgba(0,0,0,0.95)");

  ctx.fillStyle = sideGrad;
  ctx.beginPath();
  ctx.ellipse(cx, cy + h, r, r * 0.55, 0, 0, Math.PI * 2);
  ctx.fill();
}

function drawRuleHatapie() {
  const c = document.getElementById("ruleHatapie");
  const ctx = c.getContext("2d");

  const cx = 40, cy = 40, r = 20;
  const alpha = 0.85;

  const glow = ctx.createRadialGradient(cx, cy, 1, cx, cy, r);
  glow.addColorStop(0, `rgba(255,240,245,${alpha})`);
  glow.addColorStop(0.3, `rgba(255,182,193,${alpha})`);
  glow.addColorStop(0.6, `rgba(255,105,180,${alpha})`);
  glow.addColorStop(0.85, `rgba(219,112,147,${alpha * 0.8})`);
  glow.addColorStop(1, `rgba(199,21,133,0)`);

  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = `rgba(255,105,180,${0.6})`;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.stroke();
}

/* ===== ä¸€åº¦ã ã‘æç”» ===== */
drawRuleBall();
drawRuleTell();
drawRuleHatapie();

// ===== ç”»é¢å›è»¢è­¦å‘Š =====
// ãƒ¢ãƒã‚¤ãƒ«åˆ¤å®šï¼ˆiPadOSå¯¾å¿œè¾¼ã¿ï¼‰
const isMobileDevice =
  /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ||
  (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);

function updateOrientation() {

  // ãƒ¢ãƒã‚¤ãƒ«ã§ãªã‘ã‚Œã°å‡¦ç†ã—ãªã„
  if (!isMobileDevice) {
    isLandscape = false;
    return;
  }

  isLandscape = window.innerWidth > window.innerHeight;

  /* ===============================
     æ¨ªå‘ãã®å ´åˆï¼ˆå®Œå…¨é®æ–­ï¼‰
     =============================== */
  if (isLandscape) {

    if (title) title.style.display = "none";
    if (author) author.style.display = "none";
    if (startBtn) startBtn.style.display = "none";
    if (ruleBtn) ruleBtn.style.display = "none";
    if (startMessage) startMessage.style.opacity = "0";

    // â˜… è¿½åŠ ï¼šã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼è¡¨ç¤ºã‚‚æ¶ˆã™
    if (gameOverMessage) gameOverMessage.style.display = "none";

    return; // â† é‡è¦ï¼šã“ã“ã§å®Œå…¨çµ‚äº†
  }

  /* ===============================
     ç¸¦å‘ãã«æˆ»ã£ãŸå ´åˆ
     =============================== */

  if (!gameStarted) {
    if (title) title.style.display = "";
    if (author) author.style.display = "";
    if (startBtn) startBtn.style.display = "";
    if (ruleBtn) ruleBtn.style.display = "";
  }

  // â˜… ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ä¸­ãªã‚‰å†è¡¨ç¤º
  if (isGameOver && gameOverMessage) {
    gameOverMessage.style.display = "";
  }
}


window.addEventListener("resize", updateOrientation);
window.addEventListener("orientationchange", updateOrientation);

updateOrientation();


let deferredPrompt = null;

// ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ•ã¾ãˆã‚‹
window.addEventListener("beforeinstallprompt", e => {
  e.preventDefault();
  deferredPrompt = e;
});

// ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ãŸæ™‚
installBtn.onclick = async () => {
  if (!deferredPrompt) {
    alert("Installation is not available on this device yet.");
    return;
  }

  deferredPrompt.prompt();
  const result = await deferredPrompt.userChoice;

  if (result.outcome === "accepted") {
    console.log("App installed");
  }

  deferredPrompt = null;
};

function checkOrientation() {

  const wasLandscape = isLandscape;
  isLandscape = window.innerWidth > window.innerHeight;

  /* ===== æ¨ªå‘ãã«ãªã£ãŸç¬é–“ ===== */
  if (isLandscape && !wasLandscape) {

    // GAME OVER å³æ¶ˆå»
    if (gameoverLabel) {
      gameoverLabel.style.display = "none";
    }

    // â˜… ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã®ã‚¿ã‚¤ãƒãƒ¼åœæ­¢
    if (gameOverTimeout) {
      clearTimeout(gameOverTimeout);
      gameOverTimeout = null;
    }
  }

  /* ===== UIè¡¨ç¤ºåˆ¶å¾¡ ===== */
  const uiElements = [
    title,
    author,
    startBtn,
    ruleBtn,
    gameoverLabel,
    startMessage,
    scoreLabel,
    hiLabel,
    livesLabel
  ];

  uiElements.forEach(el => {
    if (!el) return;
    el.style.display = isLandscape ? "none" : "";
  });
}

window.addEventListener("resize", checkOrientation);
checkOrientation();


</script>
</body>
</html>
