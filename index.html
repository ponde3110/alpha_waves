<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flow with the Î±-waves</title>

<link rel="icon" href="favicon.ico" type="image/x-icon">

<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  width: 100%;
  height: 100%;
}

#screen {
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;      /* 100vw â†’ 100% ã«å¤‰æ›´ */
  height: 100%;     /* 100vh â†’ 100% ã«å¤‰æ›´ */
  overflow: hidden;
}

#hud {
  position:fixed;
  top:10px;
  left:0;
  width:100%;
  text-align:center;
  color:#cfe9ff;
  font-family:Arial;
  font-size:16px;
  z-index:10;
  pointer-events:none;
}

#lives {
  position:absolute;
  right:10px;
  bottom:10px;
  color:#cfe9ff;
  font-family:Arial;
  font-size:16px;
  pointer-events:none;
}

#hiscore {
  position:absolute;
  left:10px;
  top:10px;
  color:#cfe9ff;
  font-family:Arial;
  font-size:16px;
}

#score {
  position:absolute;
  right:10px;
  top:10px;
  color:#cfe9ff;
  font-family:Arial;
  font-size:16px;
}

#gameover {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  color: #ff8c1a;
  font-size: 32px;
  font-weight: bold;
  background: linear-gradient(
  to bottom,
  rgba(255,160,60,0.35),
  rgba(120,40,0,0.5)
);

  padding: 16px 32px;              /* â† æ¨ªæ–¹å‘ã‚’åºƒã’ã‚‹ */
  border-radius: 12px;
  z-index: 20;
  display: none;
  font-family: 'Arial Black', Arial, sans-serif;
  box-shadow: 0 4px 10px rgba(0,0,0,0.5);
  border: 1px solid rgba(255, 100, 100, 0.4);

  white-space: nowrap;             /* â† æ”¹è¡Œã•ã›ãªã„ï¼ˆæœ€é‡è¦ï¼‰ */
  /* min-width: 420px; â† æ¨ªé•·ã«ã™ã‚‹ */
}

#startBtn {
  position: fixed;
  top:70%;
  left:50%;
  transform: translate(-50%,-50%);
  padding:12px 24px;
  font-size:24px;
  font-weight: bold;
  border-radius:12px;
  background: linear-gradient(
  to bottom,
  rgba(255,160,60,0.35),
  rgba(120,40,0,0.5)
);
box-shadow:
  0 0 12px rgba(255,140,30,0.6),
  inset 0 0 6px rgba(255,200,120,0.4);

  color:#ff8c1a;
  cursor:pointer;
  z-index:20;
}

#muteBtn {
  position: fixed;
  left: 10px;
  bottom: 10px;   /* â† ç”»é¢æœ€ä¸‹ */
  padding: 0;
  font-size: 24px;
  background: none;
  border: none;
  color: #cfe9ff;
  cursor: pointer;
  z-index: 20;
  outline: none;
}

#title {
  position: fixed;
  top: 25%;
  left: 50%;
  transform: translate(-50%, -50%) scale(1);
  color: #ff8c1a;
  font-family: 'Arial Black', Arial, sans-serif;
  font-size: 48px;
  text-align: center;
  z-index: 12;
  pointer-events: none;
}

#author {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  color: #cfe9ff;
  font-family: Arial, sans-serif;
  font-size: 16px;
  text-align: center;
  z-index: 12;
  pointer-events: none;
}

.title-main{
  font-size:60px;
  letter-spacing:3px;

  color:#ff8c1a;     /* æœ¬ä½“ã®èµ¤ */

  white-space: nowrap;

  text-shadow:
    0 0 6px rgba(255,80,80,0.7),
    0 0 14px rgba(255,60,60,0.6),
    0 0 28px rgba(255,40,40,0.5);

  font-weight:600;
}

.title-sub{
  font-size:26px;
  letter-spacing:2px;
  margin-top:6px;
  color:#cfe9ff;
  font-family:Arial, sans-serif;

  /* æ§ãˆã‚ãªå…‰ */
  text-shadow:
    0 0 4px rgba(200,220,255,0.4),
    0 0 8px rgba(120,180,255,0.3);

  opacity:0.85;
}

#qrCode {
  position: fixed;
  right: 10px;
  bottom: 10px;
  width: 100px;
  height: auto;
  z-index: 30;
  display: none;
  filter: brightness(0.85);
  background: rgba(220,220,220,0.85);   /* â† ã“ã“å¤‰æ›´ */
  padding: 0px;
  border-radius: 8px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.5);
}


.gameover-main {
  /* ä½•ã‚‚æŒ‡å®šã—ãªã„ï¼šä»Šã¾ã§é€šã‚Šèµ¤ãƒ»ã‚µã‚¤ã‚ºç¶­æŒ */
}

.gameover-sub {
  margin-top: 8px;
  font-size: 18px;
  letter-spacing: 0.15em;
  color: #cfe9ff;
  opacity: 0.75;
  font-family: Arial, sans-serif;
}

#controlImg {
  position: fixed;
  left: 10px;
  bottom: 10px;
  width: 100px;
  height: auto;
  z-index: 25;
  pointer-events: none;
  filter: brightness(0.85);
  border-radius: 8px;
  background: rgba(220,220,220,0.85);   /* â† ã“ã“å¤‰æ›´ */
  padding: 0px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.5);
}

#startMessage {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #cfe9ff;
  font-family: Arial, sans-serif;
  font-size: 22px;
  letter-spacing: 0.1em;
  text-align: center;
  opacity: 0;
  pointer-events: none;
  z-index: 15;

  white-space: nowrap;   /* â˜… å¿…é ˆ */
  max-width: 100vw;      /* â˜… ç”»é¢å¹…åˆ¶é™ */
  overflow: hidden;      /* â˜… æŠ˜ã‚Šè¿”ã—é˜²æ­¢ */

  text-shadow:
    0 0 6px rgba(120,180,255,0.6),
    0 0 14px rgba(120,180,255,0.4);

  transition: opacity 0.8s ease;
}

#lifeUpMessage {
  position: fixed;
  top: 40%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 24px;
  color: #ff8c1a;
  font-weight: bold;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s;
  z-index: 50;
  transition: opacity 0.3s, transform 0.3s;
}

.heart {
  color: #cfe9ff;
  font-size: 28px;
  margin-right: 6px;
}



</style>
</head>
<body>

<div id="screen">
  <canvas id="canvas"></canvas>
  <div id="hiscore">HI 0</div>
  <div id="score">SCORE 0</div>
  <div id="lives"></div>
  <div id="gameover">
    <div class="gameover-main">GAME OVER</div>
   <div class="gameover-sub">Î±-wave sync lost</div>
  </div>
  <div id="startMessage">Flow with the Î±-waves</div>
  <div id="title">
    <div class="title-main">Î±-waves</div>
    <div class="title-sub">- sync and relax -</div>
  </div>
  <div id="lifeUpMessage">Life Up!</div>
  <div id="author">ponde3110&copy;</div>
  <button id="startBtn">START</button>
  <button id="muteBtn">ğŸ”Š</button>
  <img id="controlImg" src="control.png" alt="controls">
  <img id="qrCode" src="QR.png" alt="QR code">
</div>

<script>
/* ===== Audio ===== */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let audioStarted = false;
const bgGain = audioCtx.createGain();
bgGain.gain.value = 0.04;
bgGain.connect(audioCtx.destination);

const chords = [
  [220,330,440],
  [247,370,494],
  [262,392,523],
  [294,440,587]
];
let chordIndex = 0, chordTimeout;
let muted = localStorage.getItem("muted")==="true";

let sideHitFlash = 0;
let explodeColorPhase = 0;
let nextLifeScore = 50000;

let sideHitFlashLeft = 0;
let sideHitFlashRight = 0;


const muteBtn = document.getElementById("muteBtn");
muteBtn.style.display = "none";   // â† ãƒˆãƒƒãƒ—ç”»é¢ã§ã¯éè¡¨ç¤º

muteBtn.onclick = () => {
  muted = !muted;
  localStorage.setItem("muted", muted);
  bgGain.gain.value = muted ? 0 : 0.04;   // â†å…ƒã® bgGain ã‚’ä½¿ã†
  muteBtn.textContent = muted ? "ğŸ”‡" : "ğŸ”Š";
};

muteBtn.textContent = muted ? "ğŸ”‡" : "ğŸ”Š";


function playChord() {
  if (isGameOver) return;

  const freqs = [220, 330]; // å„ªã—ã„2éŸ³

  freqs.forEach(f => {
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    osc.type = "triangle";
    osc.frequency.value = f;

    g.gain.value = muted ? 0 : 0.12;

    osc.connect(g);
    g.connect(audioCtx.destination);

    osc.start();

    g.gain.exponentialRampToValueAtTime(
      0.0001,
      audioCtx.currentTime + 2.5
    );

    osc.stop(audioCtx.currentTime + 2.5);
  });

  chordTimeout = setTimeout(playChord, 5000);
}


function hitSound() {
  if (muted) return;

  const now = audioCtx.currentTime;

  /* ===== ãƒã‚¤ã‚ºï¼ˆè¡çªæ„Ÿï¼‰ ===== */
  const bufferSize = audioCtx.sampleRate * 0.12;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);

  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
  }

  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;

  const noiseFilter = audioCtx.createBiquadFilter();
  noiseFilter.type = "highpass";      // â˜… ä½éŸ³ã‚«ãƒƒãƒˆ
  noiseFilter.frequency.value = 600;

  const noiseGain = audioCtx.createGain();
  noiseGain.gain.setValueAtTime(0.35, now);
  noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

  noise.connect(noiseFilter);
  noiseFilter.connect(noiseGain);
  noiseGain.connect(audioCtx.destination);

  /* ===== ãƒ”ãƒƒã¨ã„ã†ä¸­é«˜éŸ³ ===== */
  const osc = audioCtx.createOscillator();
  const oscGain = audioCtx.createGain();

  osc.type = "square";               // â˜… ç›®ç«‹ã¤
  osc.frequency.setValueAtTime(1600, now);
  osc.frequency.exponentialRampToValueAtTime(600, now + 0.08);

  oscGain.gain.setValueAtTime(0.25, now);
  oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

  osc.connect(oscGain);
  oscGain.connect(audioCtx.destination);

  /* ===== å†ç”Ÿ ===== */
  noise.start(now);
  noise.stop(now + 0.2);

  osc.start(now);
  osc.stop(now + 0.12);
}


function bounceSound(){
  if (muted) return;

  const ctx = audioCtx;
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();

  osc.type = "sine";          // æŸ”ã‚‰ã‹ã„éŸ³
  osc.frequency.value = 880; // é«˜ã‚ï¼ˆè»½ã„åå°„æ„Ÿï¼‰

  gain.gain.value = 0.15;
  gain.gain.exponentialRampToValueAtTime(
    0.001,
    ctx.currentTime + 0.12
  );

  osc.connect(gain);
  gain.connect(ctx.destination);

  osc.start();
  osc.stop(ctx.currentTime + 0.12);
}



function destroySound() {
  const now = audioCtx.currentTime;

  // ãƒã‚¤ã‚ºç”Ÿæˆ
  const bufferSize = audioCtx.sampleRate * 2.5;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);

  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
  }

  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;

  // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼ˆå¾ã€…ã«ä½ãæ²ˆã‚€ï¼‰
  const filter = audioCtx.createBiquadFilter();
  filter.type = "lowpass";
  filter.frequency.setValueAtTime(1200, now);
  filter.frequency.exponentialRampToValueAtTime(120, now + 2.5);

  // éŸ³é‡åˆ¶å¾¡
  const gain = audioCtx.createGain();
  gain.gain.setValueAtTime(muted ? 0 : 0.35, now);
  gain.gain.exponentialRampToValueAtTime(0.0001, now + 2.8);

  noise.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);

  noise.start(now);
  noise.stop(now + 3);
}


/* ===== Canvas ===== */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  canvas.width = w;
  canvas.height = h;
}

resize();
addEventListener("resize", resize);

const W = () => canvas.width;
const H = () => canvas.height;
const scoreLabel = document.getElementById("score");
const hiLabel = document.getElementById("hiscore");
const gameoverLabel = document.getElementById("gameover");
const livesLabel = document.getElementById("lives");

const startMessage = document.getElementById("startMessage");  // ã‚¹ã‚¿ãƒ¼ãƒˆæ™‚ã«è¡¨ç¤º â†’ è‡ªå‹•ã§æ¶ˆã™

const qrCode = document.getElementById("qrCode");
const controlImg = document.getElementById("controlImg");

qrCode.style.display = "block";       // â† åˆæœŸç”»é¢ã§QRè¡¨ç¤º
controlImg.style.display = "block";  // â† åˆæœŸç”»é¢ã§controlè¡¨ç¤º


let offset = 0, score = 0, hiScore = Number(localStorage.getItem("hiScore")||0);
let lives = 3, invincible = 0, isGameOver = false, gameStarted = false, scoreStarted = false;
const roadWidth = 150;
let ballDestroyed = false, ballScale = 1;
let ballX=0, ballY=H()*0.5, ballVX=0, ballVY=0, inputX=0, inputY=0;
const BALL_R = 14;
const keys = {};

// ===== ã‚¹ãƒãƒ›å‚¾ãæ“ä½œ =====
let tiltInputX = 0, tiltInputY = 0;

function enableDeviceOrientation() {
  if (typeof DeviceOrientationEvent !== 'undefined' &&
      typeof DeviceOrientationEvent.requestPermission === 'function') {
    DeviceOrientationEvent.requestPermission().then(res=>{
      if(res==='granted') window.addEventListener('deviceorientation', handleOrientation);
    }).catch(console.error);
  } else {
    window.addEventListener('deviceorientation', handleOrientation);
  }
}

function handleOrientation(e) {
  let x = e.gamma || 0; // å·¦å³
  let y = e.beta  || 0; // ä¸Šä¸‹

  const angle = screen.orientation?.angle || 0;

  switch (angle) {
    case 0: // portrait
      break;
    case 90: // landscape right
      [x, y] = [y, -x];
      break;
    case 180: // upside-down
      x = -x;
      y = -y;
      break;
    case 270: // landscape left
      [x, y] = [-y, x];
      break;
  }

  const sensitivity = 0.04;
  tiltInputX = x * sensitivity;
  tiltInputY = y * sensitivity;
}



/* ===== æ˜Ÿ ===== */
const stars = [];
for (let i=0; i<120; i++) {
  stars.push({
    x: Math.random()*W(),
    y: Math.random()*H(),
    d: Math.random()*2+0.5,
    s: Math.random()*0.8+0.3,
    a: Math.random()*0.6+0.3,
    c: [[255,255,255],[200,220,255],[255,235,200]][Math.random()*3|0]
  });
}

function drawStars() {

  // ===== ç´«ãŒã¯ã£ãã‚Šè¦‹ãˆã‚‹å®‡å®™èƒŒæ™¯ =====
const bg = ctx.createLinearGradient(0, 0, 0, H());

// ä¸Šï¼šã‹ãªã‚Šç´«
bg.addColorStop(0, "#3a0060");

// å°‘ã—ä¸‹
bg.addColorStop(0.25, "#2b0040");

// ä¸­é–“
bg.addColorStop(0.6, "#140020");

// ä¸‹ï¼šã»ã¼é»’
bg.addColorStop(1, "#020008");


  ctx.fillStyle = bg;
  ctx.fillRect(0,0,W(),H());

  stars.forEach(s => {
    s.y += 0.12 * s.d;
    if (s.y > H()) {
      s.y = 0;
      s.x = Math.random()*W();
    }
    ctx.fillStyle = `rgba(${s.c[0]},${s.c[1]},${s.c[2]},${s.a})`;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.s*s.d, 0, Math.PI*2);
    ctx.fill();
  });
}


/* ===== ãƒ†ãƒ« ===== */
const holes = [];

function spawnHole() {
  holes.push({
    y: -40,
    xOffset: (Math.random() - 0.5) * roadWidth * 0.6,
    r: 6 + Math.random() * (4 + score / 20000),
    h: 12 + Math.random() * 10   // é«˜ã•ï¼ˆç«‹ä½“æ„Ÿç”¨ï¼‰
  });
}




/* ===== é“ ===== */
function roadCenter(y) {
  return W()/2 + Math.sin((y+offset)*0.01)*80 + Math.sin((y+offset)*0.03)*30;
}


function drawRoad() {
  const leftEdge = [];
  const rightEdge = [];

  // é“ã®ä¸­å¿ƒã¨å¹…
  for (let y = 0; y <= H(); y += 2) {
    const cx = roadCenter(y);
    const t = y / H();
    const perspective = 0.1 + t * 1.0;
    const w = roadWidth * perspective;

    leftEdge.push({ x: cx - w / 2, y });
    rightEdge.push({ x: cx + w / 2, y });
  }

  /* ===== è·¯é¢ ===== */
  for (let i = 0; i < leftEdge.length; i++) {
    const y = leftEdge[i].y;
    const lx = leftEdge[i].x;
    const rx = rightEdge[i].x;

    const roadGrad = ctx.createLinearGradient(lx, 0, rx, 0);
    roadGrad.addColorStop(0, "#2a7a6d");
    roadGrad.addColorStop(0.35, "#145046");
    roadGrad.addColorStop(0.5, "#0a2a26");
    roadGrad.addColorStop(0.65, "#145046");
    roadGrad.addColorStop(1, "#2a7a6d");

    ctx.fillStyle = roadGrad;
    ctx.fillRect(lx, y, rx - lx, 2);

    // é è¿‘ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆç¸¦æ–¹å‘ï¼‰
    const depthGrad = ctx.createLinearGradient(0, 0, 0, H());
    depthGrad.addColorStop(0, "rgba(0,0,0,0.65)");
    depthGrad.addColorStop(0.45, "rgba(0,0,0,0.25)");
    depthGrad.addColorStop(1, "rgba(255,255,255,0.12)");
    ctx.fillStyle = depthGrad;
    ctx.fillRect(lx, y, rx - lx, 2);
  }

// é“ã®ç¸ï¼ˆå¥¥è¡Œãåæ˜ ï¼‰
ctx.lineWidth = 6;
for (let i = 0; i < leftEdge.length; i++) {
  const t = leftEdge[i].y / H();
  const perspective = 0.1 + t * 1.0;
  let alpha = 0.3 + 0.7 * perspective; // æ‰‹å‰ã»ã©æ¿ƒã

  // å·¦ç¸
  ctx.strokeStyle = sideHitFlashLeft > 0
    ? `rgba(255,255,150,${alpha})`  // å…‰ã‚‹è‰²
    : `rgba(40,120,100,${alpha})`;
  ctx.beginPath();
  ctx.moveTo(leftEdge[i].x, leftEdge[i].y);
  if (i < leftEdge.length - 1) ctx.lineTo(leftEdge[i + 1].x, leftEdge[i + 1].y);
  ctx.stroke();

  // å³ç¸
  ctx.strokeStyle = sideHitFlashRight > 0
    ? `rgba(255,255,150,${alpha})`  // å…‰ã‚‹è‰²
    : `rgba(40,120,100,${alpha})`;
  ctx.beginPath();
  ctx.moveTo(rightEdge[i].x, rightEdge[i].y);
  if (i < rightEdge.length - 1) ctx.lineTo(rightEdge[i + 1].x, rightEdge[i + 1].y);
  ctx.stroke();
}

// ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚’æ¸›ç®—
if (sideHitFlashLeft > 0) sideHitFlashLeft--;
if (sideHitFlashRight > 0) sideHitFlashRight--;


  /* ===== ã‚»ãƒ³ã‚¿ãƒ¼ãƒ©ã‚¤ãƒ³ ===== */
  ctx.strokeStyle = "rgba(140,220,180,0.35)";
  ctx.lineWidth = 2;
  ctx.setLineDash([3, 3]);
  ctx.beginPath();
  for (let i = 0; i < leftEdge.length; i++) {
    const cx = (leftEdge[i].x + rightEdge[i].x) / 2;
    if (i === 0) ctx.moveTo(cx, leftEdge[i].y);
    else ctx.lineTo(cx, leftEdge[i].y);
  }
  ctx.stroke();
  ctx.setLineDash([]);

  /* ===== é“å°‚ç”¨ãƒ•ã‚©ã‚° ===== */
  ctx.save();
  ctx.beginPath();
  for (let i = 0; i < leftEdge.length; i++) {
    if (i === 0) ctx.moveTo(leftEdge[i].x, leftEdge[i].y);
    else ctx.lineTo(leftEdge[i].x, leftEdge[i].y);
  }
  for (let i = rightEdge.length - 1; i >= 0; i--) {
    ctx.lineTo(rightEdge[i].x, rightEdge[i].y);
  }
  ctx.closePath();
  ctx.clip();

  const fog = ctx.createLinearGradient(0, 0, 0, H() * 0.1);
  fog.addColorStop(0, "rgba(20,0,40,1)");
  fog.addColorStop(1, "rgba(20,0,40,0)");
  ctx.fillStyle = fog;
  ctx.fillRect(0, 0, W(), H() * 0.1);
  ctx.restore();

// ä¸Šã‹ã‚‰æŒ¯ã£ã¦ãã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚’æç”»
holes.forEach(o => {
  if (o.y < 0 || o.y > H()) return;

  const t = o.y / H();
  const perspective = 0.1 + t * 1.0;

  const cx = roadCenter(o.y) + o.xOffset;

  // â˜… è·¯é¢ã«æ¥åœ°ã•ã›ã‚‹è£œæ­£ï¼ˆå°‘ã—ä¸‹ã¸ï¼‰
  const cy = o.y + 6 * perspective;

  const r = o.r * perspective;
  const h = o.h * perspective;

  /* ===== è·¯é¢å½± ===== */
  ctx.fillStyle = `rgba(0,0,0,${0.35 * perspective})`;
  ctx.beginPath();
  ctx.ellipse(cx, cy + h, r * 1.1, r * 0.55, 0, 0, Math.PI * 2);
  ctx.fill();

  /* ===== æœ¬ä½“ä¸Šé¢ ===== */
  const topGrad = ctx.createRadialGradient(cx, cy, 2, cx, cy, r);
  topGrad.addColorStop(0, "#442060");
  topGrad.addColorStop(1, "#140018");

  ctx.fillStyle = topGrad;
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fill();

  /* ===== å´é¢ ===== */
  const sideGrad = ctx.createLinearGradient(cx, cy, cx, cy + h);
  sideGrad.addColorStop(0, "rgba(80,0,120,0.8)");
  sideGrad.addColorStop(1, "rgba(0,0,0,0.95)");

  ctx.fillStyle = sideGrad;
  ctx.beginPath();
  ctx.ellipse(cx, cy + h, r, r * 0.55, 0, 0, Math.PI * 2);
  ctx.fill();

  /* ===== æ¥åœ°ç¸ãƒã‚¤ãƒ©ã‚¤ãƒˆ ===== */
  ctx.strokeStyle = `rgba(190,130,255,${0.3 + 0.4 * perspective})`;
  ctx.lineWidth = 2 * perspective;
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.stroke();
});




}




/* ===== ãƒœãƒ¼ãƒ«æç”» ===== */
function drawBall() {
  if (isGameOver) return;

  /* ===== çƒã®ä¸­å¿ƒåº§æ¨™ ===== */
  const cy = gameStarted ? ballY : H() * 0.5;               // Yåº§æ¨™
  const cx = roadCenter(cy) + (gameStarted ? ballX : 0);    // é“ã®ä¸­å¤®ã«é…ç½®
  const t = cy / H();                                       // é è¿‘ä¿‚æ•°
  const perspective = 0.1 + t * 1.0;                        // 0.1ã€œ1.1
  const r = BALL_R * perspective * ballScale;               // ãƒœãƒ¼ãƒ«åŠå¾„ï¼ˆé è¿‘ãƒ»ã‚¹ã‚±ãƒ¼ãƒ«åæ˜ ï¼‰

  /* ===== å½± ===== */
  const shadowWidth = 14 * perspective;  // æ¨ªã‚’å°‘ã—å¤§ãã
  const shadowHeight = 5 * perspective; // ç¸¦ã‚‚å¤§ãã
  const shadowAlpha = 0.4 * perspective; // å¥¥è¡Œãã§è–„ã

  ctx.fillStyle = `rgba(0,0,0,${shadowAlpha})`;
  ctx.beginPath();
  ctx.ellipse(cx, cy + 10 * perspective, shadowWidth, shadowHeight, 0, 0, Math.PI * 2);
  ctx.fill();

  /* ===== é€šå¸¸ãƒ—ãƒ¬ã‚¤ä¸­ ===== */
  if (!ballDestroyed) {
    let g;

    if (sideHitFlash > 0) {
      // æ¨ªãƒ’ãƒƒãƒˆæ™‚ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
      g = ctx.createRadialGradient(
        cx - 6 * perspective,
        cy - 6 * perspective,
        2 * perspective,
        cx,
        cy,
        r * 1.1
      );
      g.addColorStop(0, "#ffffff");
      g.addColorStop(0.6, "#ffd8a0");
      g.addColorStop(1, "#ff8c1a");
      sideHitFlash--;
    } else {
      // é€šå¸¸ãƒœãƒ¼ãƒ«
      g = ctx.createRadialGradient(
        cx - 5 * perspective,
        cy - 5 * perspective,
        2 * perspective,
        cx,
        cy,
        r * 1.1
      );
      g.addColorStop(0, "#fff2dd");
      g.addColorStop(1, "#ff8c1a");
    }

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fill();

  } else {
    /* ===== çˆ†ç™ºæ¼”å‡º ===== */
    explodeFrame += 0.05;
    explodeColorPhase += 0.04;

    const rCol = 255;
    const gCol = Math.floor(140 + 80 * explodeColorPhase);
    const bCol = Math.floor(40 + 40 * explodeColorPhase);

    // ä¸­å¤®ã‚³ã‚¢
    const coreR = BALL_R * (1 - explodeFrame * 0.05);
    if (coreR > 0) {
      const gCore = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreR);
      gCore.addColorStop(0, `rgba(${rCol},${gCol},${bCol},0.95)`);
      gCore.addColorStop(1, `rgba(${rCol},${gCol},${bCol},0.3)`);
      ctx.fillStyle = gCore;
      ctx.beginPath();
      ctx.arc(cx, cy, coreR, 0, Math.PI * 2);
      ctx.fill();
    }

    // æ‹¡æ•£ãƒªãƒ³ã‚°
    const ringR = BALL_R + explodeFrame * 3;
    const ringAlpha = Math.max(0, 1 - explodeFrame * 0.06);
    if (ringAlpha > 0) {
      ctx.strokeStyle = `rgba(${rCol},${gCol},${bCol},${ringAlpha})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, ringR, 0, Math.PI * 2);
      ctx.stroke();
    }
  }
}



/* ===== ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ ===== */
function updateGameOver() {
  if (isGameOver) return;

  lives = 0;
  updateLivesDisplay();

  clearTimeout(chordTimeout);
  isGameOver = true;
  gameoverLabel.style.display = "block";
  muteBtn.style.display = "block";   // â† GAME OVER ã§ã‚‚è¡¨ç¤º


  hiScore = Math.max(hiScore, score);
  localStorage.setItem("hiScore", Math.floor(hiScore));
  hiLabel.textContent = "HI " + Math.floor(hiScore);

  setTimeout(() => {
    gameStarted = false;
    isGameOver = false;

    gameoverLabel.style.display = "none";
    title.style.display = "block";
    author.style.display = "block";
    startBtn.style.display = "block";
    qrCode.style.display = "block";

    controlImg.style.display = "block";   // â† ãƒˆãƒƒãƒ—å¾©å¸°ã§å†è¡¨ç¤º

    ballX = 0;
    ballY = H() * 0.5;
    ballVX = 0;
    ballVY = 0;
    inputX = 0;
    inputY = 0;
  }, 5000);
}



/* ===== ã‚­ãƒ¼æ“ä½œ ===== */
addEventListener("keydown", e => {
  keys[e.code] = true;
  if(!scoreStarted && (e.code==="ArrowLeft" || e.code==="ArrowRight")) scoreStarted = true;
});
addEventListener("keyup", e => keys[e.code] = false);

/* ===== ãƒ©ã‚¤ãƒ•è¡¨ç¤º ===== */
const maxLives = 5;
function updateLivesDisplay(){
  // ãƒˆãƒƒãƒ—ç”»é¢ã§ã¯è¡¨ç¤ºã—ãªã„
  if (!gameStarted) {
    livesLabel.innerHTML = "";
    return;
  }

  livesLabel.innerHTML = "";

for (let i = 0; i < lives; i++) {
  const heart = document.createElement("span");
  heart.className = "heart";
  heart.textContent = "â™¥";
  livesLabel.appendChild(heart);
}

}


/* ===== ãƒœãƒ¼ãƒ«æ›´æ–° ===== */
function updateBall(){
  if (ballDestroyed) return;

  /* ===== å…¥åŠ›å‡¦ç† ===== */
  const tx = (keys.ArrowRight ? 1 : 0) - (keys.ArrowLeft ? 1 : 0);
  const ty = (keys.ArrowDown  ? 1 : 0) - (keys.ArrowUp   ? 1 : 0);

  const targetX = tx + tiltInputX;
  const targetY = ty + tiltInputY * 0.4;

  inputX += (targetX - inputX) * 0.02;
  inputY += (targetY - inputY) * 0.02;

  ballVX += inputX * 0.06;
  ballVY += inputY * 0.06;

  ballVX *= 0.96;
  ballVY *= 0.96;

  const t = ballY / H();
  const perspective = 0.1 + t * 1.0;
  const limit = (roadWidth * perspective) / 2 - BALL_R;

  const bouncePower = 5.0;

  /* ===== ç§»å‹• ===== */
  ballX += ballVX;
  ballY += ballVY;

  /* ===== ä¸Šç«¯ ===== */
  const upperLimit = H() * 0.2;
  if (ballY <= upperLimit) {
    ballY = upperLimit;
    ballVY = +bouncePower;

    if (Math.abs(ballVX) < 0.3) {
      ballVX = (Math.random() < 0.5 ? -1 : 1) * 0.7;
    } else {
      ballVX *= 1.15;
    }
    bounceSound();
  }

  /* ===== ä¸‹ç«¯ ===== */
  if (ballY >= H() - 20) {
    ballY = H() - 20;
    ballVY = -bouncePower;

    if (Math.abs(ballVX) < 0.3) {
      ballVX = (Math.random() < 0.5 ? -1 : 1) * 0.7;
    } else {
      ballVX *= 1.15;
    }
    bounceSound();
  }

  /* ===== å·¦å³ ===== */
  if (ballX >= limit && invincible <= 0) {
    ballVX *= -1.1;
    invincible = 60;
    sideHitFlashRight = 6;
    sideHitFlash = 6;
    hitSound();

    lives--;
    updateLivesDisplay();
    if (lives === 0) gameOverPending = true;
  }

  if (ballX <= -limit && invincible <= 0) {
    ballVX *= -1.1;
    invincible = 60;
    sideHitFlashLeft = 6;
    sideHitFlash = 6;
    hitSound();

    lives--;
    updateLivesDisplay();
    if (lives === 0) gameOverPending = true;
  }

  /* ===== ğŸ”¥ éšœå®³ç‰©ã¨ã®è¡çªåˆ¤å®šï¼ˆè¿½åŠ éƒ¨åˆ†ï¼‰ ===== */
holes.forEach((o, i) => {

  if (invincible > 0) return;

  const tObj = o.y / H();
  const pObj = 0.1 + tObj * 1.0;

  const cx = roadCenter(o.y) + o.xOffset;

  // â˜… æå†™ã¨åŒã˜æ¥åœ°è£œæ­£ã‚’åæ˜ 
  const cy = o.y + 6 * pObj;

  const objR = o.r * pObj;

  const tBall = ballY / H();
  const pBall = 0.1 + tBall * 1.0;

  const ballCX = roadCenter(ballY) + ballX;
  const ballCY = ballY;
  const ballR  = BALL_R * pBall;

  const dx = ballCX - cx;
  const dy = ballCY - cy;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist < ballR + objR * 0.85) {

    invincible = 60;
    lives--;
    updateLivesDisplay();
    tellDestroySound();


    holes.splice(i,1);


    if (lives <= 0) gameOverPending = true;
  }
});


  /* ===== ã‚¯ãƒ©ãƒ³ãƒ— ===== */
  if (ballX >  limit) ballX =  limit;
  if (ballX < -limit) ballX = -limit;
  if (ballY < 20)     ballY = 20;
  if (ballY > H() - 20) ballY = H() - 20;

  if (invincible > 0) invincible--;
}




let gameOverPending = false;
let explodeFrame = 0;

/* ===== ãƒ«ãƒ¼ãƒ— ===== */
function loop(){
  if(!hiLabel.dataset.init){
    hiLabel.textContent = "HI " + Math.floor(hiScore);
    hiLabel.dataset.init = true;
  }

  drawStars();
  drawRoad();

  // ===== ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é€Ÿåº¦åˆ¶å¾¡ï¼ˆå®Œå…¨ãƒ»åœæ­¢ã—ãªã„ï¼‰=====

  const baseSpeed = 0.12;   // æœ€ä½é€Ÿåº¦ã‚’ä¸‹ã’ã‚‹

if (gameStarted) {

  // ä¸Šã«è¡Œã£ã¦ã‚‚æš´èµ°ã—ãªã„ forward
  let forward = (ballY / H()) * 0.9;


  // æœ€å¤§é€Ÿåº¦ã‚’åˆ¶é™
  forward = Math.min(forward, 0.9);

  offset += baseSpeed + forward;

 // ãƒ†ãƒ«ã‚’ç™ºç”Ÿï¼†æµã™å‡¦ç†
const tellLevel = Math.min(5, 1 + score / 100000); // 20000ãªã‚‰åœ°ç„

if (
  gameStarted &&
  score >= 10000 &&           // â† 1ä¸‡ç‚¹è¶…ãˆã¦ã‹ã‚‰è§£ç¦
  Math.random() < 0.0010 * tellLevel
) {
  spawnHole();
}


holes.forEach(h => {
  h.y += 0.6;ã€€// 1.4ãªã‚‰å¤šã‚
});


  if (!isGameOver) {
    score += (0.25 + forward) * 10;
  }
}
 else {
    // æœ¬å½“ã®ãƒˆãƒƒãƒ—ç”»é¢
    offset += baseSpeed;
  }

  if(gameStarted && !isGameOver) updateBall();

  drawBall();
  scoreLabel.textContent = "SCORE " + Math.floor(score);

// ===== ã‚¹ã‚³ã‚¢ã«ã‚ˆã‚‹ãƒ©ã‚¤ãƒ•å›å¾©ï¼ˆä¿®æ­£ç‰ˆãƒ»ç¢ºå®šï¼‰=====
if (score >= nextLifeScore) {

  if (lives < maxLives) {
    lives++;

    lifeUpSound();

    if (lives === maxLives) {
      lifeUpMessage.style.color = "#ffd700"; // gold
      showLifeUpMessage("Max Life!");   // â˜… æº€ã‚¿ãƒ³è¡¨ç¤º
    } else {
      lifeUpMessage.style.color = "#ff8c1a"; // heart color
      showLifeUpMessage("Life Up!");
    }

    updateLivesDisplay();
  }

  nextLifeScore += 50000;
}


  if(gameOverPending && !isGameOver){
    if(Math.abs(ballVX) < 1 && Math.abs(ballVY) < 1){
      ballDestroyed = true;
      destroySound();
      explodeFrame = 0;   // â† è¿½åŠ 
      explodeColorPhase = 0;   // â˜… è¿½åŠ 
      gameOverPending = false;
      setTimeout(()=>{
        updateGameOver();
        ballDestroyed = false;
        ballScale = 1;
      },1000);
    }
  }

  requestAnimationFrame(loop);
}

loop();


/* ===== ã‚¿ã‚¤ãƒˆãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ ===== */
const title = document.getElementById("title");
const author = document.getElementById("author");
let titleScale = 1, scaleDirection = 1;
function animateTitle() {
  if(!gameStarted){
    titleScale += 0.0025 * scaleDirection;
    if(titleScale > 1.15) scaleDirection = -1;
    if(titleScale < 0.95) scaleDirection = 1;
    title.style.transform = `translate(-50%, -50%) scale(${titleScale})`;
  }
  requestAnimationFrame(animateTitle);
}
animateTitle();

/* ===== STARTãƒœã‚¿ãƒ³ï¼ˆå®Œæˆç‰ˆï¼‰ ===== */
startBtn.onclick = () => {

  /* --- UIã‚’éè¡¨ç¤ºï¼è¡¨ç¤º --- */
  startBtn.style.display = "none";
  title.style.display = "none";
  author.style.display = "none";

  qrCode.style.display = "none";      // ãƒ—ãƒ¬ã‚¤ä¸­ã¯éè¡¨ç¤º
  controlImg.style.display = "none";  // æ“ä½œèª¬æ˜ã‚’æ¶ˆã™
  muteBtn.style.display = "block";    // ã‚²ãƒ¼ãƒ ä¸­ã®ã¿è¡¨ç¤º

  /* --- ã‚¹ãƒªãƒ¼ãƒ—é˜²æ­¢ï¼ˆå¯¾å¿œç«¯æœ«ã®ã¿ï¼‰ --- */
  if ('wakeLock' in navigator) {
    enableWakeLock();
  }

  /* --- ã‚²ãƒ¼ãƒ çŠ¶æ…‹åˆæœŸåŒ– --- */
  gameStarted = true;
  scoreStarted = true;
  isGameOver = false;

  lives = 3;
  updateLivesDisplay();   // â˜… ã“ã“ã«å…¥ã‚Œã‚‹
  score = 0;
  nextLifeScore = 50000;

  ballX = 0;
  ballY = H() * 0.5;
  ballVX = 0;   // â˜… å°‘ã—å³ãªã‚‰0.4
  ballVY = 0;     // â˜… ä¸Šæ˜‡ã—ãªã„

  inputX = 0;
  inputY = 0;

  chordPlaying = false;

  /* --- BGMé–‹å§‹ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå†…ï¼‰ --- */
  audioCtx.resume().then(() => {
    playChord();
  });

  /* --- ã‚¸ãƒ£ã‚¤ãƒ­æœ‰åŠ¹åŒ–ï¼ˆã‚¹ãƒãƒ›ï¼‰ --- */
  enableDeviceOrientation();

  // ===== ã‚¹ã‚¿ãƒ¼ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º =====
startMessage.style.opacity = "1";

setTimeout(() => {
  startMessage.style.opacity = "0";
}, 3000); // â† è¡¨ç¤ºæ™‚é–“ï¼ˆmsï¼‰

};


// ===== ENTERã‚­ãƒ¼ã§ã‚¹ã‚¿ãƒ¼ãƒˆ =====
addEventListener("keydown", e => {
  if (!gameStarted && (e.code === "Enter" || e.code === "NumpadEnter")) {
    startBtn.onclick(); // ãƒœã‚¿ãƒ³ã®å‡¦ç†ã‚’ãã®ã¾ã¾å‘¼ã³å‡ºã™
  }
});

let wakeLock = null;

// Wake Lockã‚’è¦æ±‚ã™ã‚‹é–¢æ•°
async function enableWakeLock() {
  try {
    wakeLock = await navigator.wakeLock.request('screen');
    // console.logã ã‘ã«ã™ã‚‹ã®ã§ç”»é¢è¡¨ç¤ºã¯ãªã—
    console.log('Wake Lock ãŒæœ‰åŠ¹ã«ãªã‚Šã¾ã—ãŸ');

    wakeLock.addEventListener('release', () => {
      console.log('Wake Lock ãŒè§£é™¤ã•ã‚Œã¾ã—ãŸ');
    });
  } catch (err) {
    console.error('Wake Lock ã®å–å¾—ã«å¤±æ•—:', err);
  }
}

// Wake Lockã‚’è§£é™¤ã™ã‚‹é–¢æ•°
function disableWakeLock() {
  if (wakeLock !== null) {
    wakeLock.release();
    wakeLock = null;
    console.log('Wake Lock ã‚’è§£é™¤ã—ã¾ã—ãŸ');
  }
}

// ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«å‘¼ã¶
enableWakeLock();

// ã‚¿ãƒ–éè¡¨ç¤ºâ†’è¡¨ç¤ºã«ãªã£ãŸã¨ãã«å†å–å¾—
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    enableWakeLock();
  } else {
    wakeLock = null;
  }
});

// ===== ãƒ©ã‚¤ãƒ•å›å¾©ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ =====
const lifeUpMessage = document.getElementById("lifeUpMessage");

function showLifeUpMessage(text = "Life Up!") {
  lifeUpMessage.textContent = text;
  lifeUpMessage.style.opacity = 1;

  setTimeout(() => {
    lifeUpMessage.style.opacity = 0;
  }, 800);
}

function lifeUpSound() {
  if (muted) return;       // â˜… ãƒŸãƒ¥ãƒ¼ãƒˆå¯¾å¿œ
  if (!audioCtx) return;

  const osc1 = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  // éŸ³è‰²
  osc1.type = "sine";
  osc2.type = "triangle";

  // å‘¨æ³¢æ•°ï¼ˆãƒãƒ£ãƒªãƒ³æ„Ÿï¼‰
  osc1.frequency.setValueAtTime(1200, audioCtx.currentTime);
  osc2.frequency.setValueAtTime(1800, audioCtx.currentTime);

  gain.gain.setValueAtTime(0.18, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(
    0.0001,
    audioCtx.currentTime + 0.35
  );

  osc1.connect(gain);
  osc2.connect(gain);
  gain.connect(audioCtx.destination);

  osc1.start();
  osc2.start();

  osc1.stop(audioCtx.currentTime + 0.35);
  osc2.stop(audioCtx.currentTime + 0.35);
}

function ballPerspectiveRadius(y) {
  const t = y / H();
  return BALL_R * t * ballScale;
}



// ===== ãƒ†ãƒ«ã®æ¶ˆæ»…éŸ³ =====
function tellDestroySound() {
  if (muted) return;

  const now = audioCtx.currentTime;

  // å£°ã®æ¯æˆåˆ†
  const bufferSize = audioCtx.sampleRate * 0.09;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);

  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
  }

  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;

  // ãƒ•ã‚©ãƒ«ãƒãƒ³ãƒˆï¼ˆäººã®å£°å¸¯åŸŸï¼‰
  const f1 = audioCtx.createBiquadFilter();
  f1.type = "bandpass";
  f1.frequency.value = 700;   // ãƒ†

  const f2 = audioCtx.createBiquadFilter();
  f2.type = "bandpass";
  f2.frequency.value = 1800; // ãƒ«

  const f3 = audioCtx.createBiquadFilter();
  f3.type = "bandpass";
  f3.frequency.value = 2600;  // å­éŸ³è¼ªéƒ­

  const gain = audioCtx.createGain();
  gain.gain.setValueAtTime(0.25, now);
  gain.gain.linearRampToValueAtTime(0.05, now + 0.04);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.16);

  noise.connect(f1);
  f1.connect(f2);
  f2.connect(f3);
  f3.connect(gain);
  gain.connect(audioCtx.destination);

  noise.start(now);
  noise.stop(now + 0.16);

  // å£°ã®èŠ¯ï¼ˆå–‰ï¼‰
  const osc = audioCtx.createOscillator();
  const og = audioCtx.createGain();

  osc.type = "sawtooth";
  osc.frequency.setValueAtTime(210, now);
  osc.frequency.exponentialRampToValueAtTime(160, now + 0.12);

  og.gain.setValueAtTime(0.07, now);
  og.gain.exponentialRampToValueAtTime(0.001, now + 0.16);

  osc.connect(og);
  og.connect(audioCtx.destination);

  osc.start(now);
  osc.stop(now + 0.16);
}



</script>
</body>
</html>
